<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>运行时重新配置</title>
    <link href="undefined2019/11/23/blog/etcd/%E8%BF%90%E8%A1%8C%E6%97%B6%E9%87%8D%E6%96%B0%E9%85%8D%E7%BD%AE/"/>
    <url>2019/11/23/blog/etcd/%E8%BF%90%E8%A1%8C%E6%97%B6%E9%87%8D%E6%96%B0%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>etcd带有增量运行时重新配置的支持。允许我们在集群运行的时候更新集群成员关系。<br>仅当大多数集群成员都在运行时，才能处理重新配置请求，强烈建议在生产环境中集群的大小应该始终大于2。从两个成员的集群中移除一个成员是不安全的。两个成员的集群中大多数成员始终是2，如果在删除过程中出现故障，集群将很难继续运行需要重新从<a href="">主要成员失败中重新启动集群</a>。<br>为了更好的理解运行时重新配置设计，请阅读<a href="./运行时重新配置设计.md">运行时重新配置设计</a>。</p><h2 id="重新配置使用案例"><a href="#重新配置使用案例" class="headerlink" title="重新配置使用案例"></a>重新配置使用案例</h2><hr><p>本节将介绍一些重新配置集群的常见原因。 其中大多数原因仅涉及添加或删除成员的组合，<a href="">群集重新配置操作</a>下将对此进行说明。</p><h3 id="循环或更新多机"><a href="#循环或更新多机" class="headerlink" title="循环或更新多机"></a>循环或更新多机</h3><p>如果由于计划的维护（硬件升级，网络停机等）而需要移动多个群集成员，建议一次修改一个成员。<br>移除领导者是安全的，但是在选举过程中会出现短暂的停机时间。 如果群集包含的版本为v2的数据超过50MB，则建议迁移成员的数据目录。</p><h3 id="改变集群大小"><a href="#改变集群大小" class="headerlink" title="改变集群大小"></a>改变集群大小</h3><p>增加群集大小可以增强<a href="">容错能力</a>并提供更好的读取性能,由于客户端可以从任何成员读取，因此增加成员数量将增加整体序列化读取吞吐量。<br>减小群集大小可以提高群集的写入性能，但需要权衡降低弹性。写入集群之前，会将其复制到集群的大多数成员。 减小群集大小可减少大多数操作，并且每次写入的提交速度都会更快。</p><h3 id="替换一个失败的主机"><a href="#替换一个失败的主机" class="headerlink" title="替换一个失败的主机"></a>替换一个失败的主机</h3><p>如果计算机由于硬件故障，数据目录损坏或其他致命情况而失败，应该尽快更换它。 发生故障但尚未移除的主机会对集群产生不利影响，并降低对其他故障的容忍度。<br>要更换主机，请按照说明从群集中删除成员，然后在其位置添加新成员。如果群集拥有的空间超过50MB，则建议迁移仍可访问的失败成员的数据目录。</p><h3 id="多数主机失败后重启集群"><a href="#多数主机失败后重启集群" class="headerlink" title="多数主机失败后重启集群"></a>多数主机失败后重启集群</h3><p>如果大多数群集丢失或所有节点的IP地址都已更改，则必须采取手动操作才能安全恢复。恢复过程中的基本步骤包括<a href="">使用旧数据创建新集群</a>，强制单个成员充当领导者，最后使用运行时配置一次将<a href="">新成员添加</a>到该新集群中。</p><h2 id="集群重新配置操作"><a href="#集群重新配置操作" class="headerlink" title="集群重新配置操作"></a>集群重新配置操作</h2><p>考虑到这些用例，可以针对每个用例进行描述。进行任何更改之前，必须有多数etcd成员可以获取。 对于对etcd的任何类型的写入，这基本上是相同的要求。<br>必须按顺序完成对集群的所有更改：</p><ul><li>要更新单个成员节点URL，请执行更新操作.</li><li>要替换正常的单个成员，请删除旧成员，然后添加新成员.</li><li>要从3名增加到5名成员，请执行两次添加操作</li><li>成员数量要从5减少到3，请执行两次删除操作</li></ul><p>这些示例都使用etcd附带的<code>etcdctl</code>命令行工具进行。如果不使用<code>etcdctl</code>工具改变成员关系，使用<a href="">v2HTTP成员API</a>或者<a href="">v3gRPC成员API</a>。</p><h3 id="更新一个成员"><a href="#更新一个成员" class="headerlink" title="更新一个成员"></a>更新一个成员</h3><p><strong>更新广播客户端URLs</strong><br>要更新成员的发布客户端URL，只需使用已更新的客户端URL参数<code>--advertise-client-urls</code>或环境变量<code>ETCD_ADVERTISE_CLIENT_URLS</code>重新启动该成员。重新启动的成员将自行发布更新的URL。 错误更新的客户端URL不会影响etcd群集的运行状况。<br><strong>更新广播节点URLs</strong><br>要更新成员的广播节点URL，请首先通过成员命令显式更新它，然后重新启动该成员。由于更新节点URL会更改集群范围的配置，并且可能影响etcd集群的运行状况，因此需要采取其他措施。<br>要更新成员的广播节点URL，请首先找到目标成员的ID。 列出具有etcdctl的所有成员：</p><pre><code>$ etcdctl member list6e3bd23ae5f1eae0: name=node2 peerURLs=http://localhost:23802 clientURLs=http://127.0.0.1:23792924e2e83e93f2560: name=node3 peerURLs=http://localhost:23803 clientURLs=http://127.0.0.1:23793a8266ecf031671f3: name=node1 peerURLs=http://localhost:23801 clientURLs=http://127.0.0.1:23791</code></pre><p>本示例将<code>更新</code>a8266ecf031671f3成员ID，并将其节点URLs值更改为<code>http://10.0.1.10:2380</code>：</p><pre><code>$ etcdctl member update a8266ecf031671f3 --peer-urls=http://10.0.1.10:2380Updated member with ID a8266ecf031671f3 in cluster</code></pre><p><strong>移除一个成员</strong><br>假设要移除的成员ID为a8266ecf031671f3。 使用<code>remove</code>命令执行删除：</p><pre><code>$ etcdctl member remove a8266ecf031671f3Removed member a8266ecf031671f3 from cluster</code></pre><p>目标成员将在此时停止运行并在日志中打印出删除内容：</p><pre><code>etcd: this member has been permanently removed from the cluster. Exiting.</code></pre><p>删除领导者是安全的，但是当选择新领导者时，群集将处于非活动状态。 此持续时间通常是选举超时时间加上投票过程的时间。<br><strong>添加一个新成员</strong><br>通过两个步骤添加一个新的成员：</p><ul><li>通过<a href="">HTTP 成员API</a>，<a href="">gRPC成员API</a>，或者是<code>etcdctl member add</code>命令添加一个新的成员到集群中。</li><li>通过新的集群配置启动新的成员，新的集群配置包括被更新的成员(已存在的成员+新成员).</li></ul><p><code>etcdctl</code>添加一个新的成员到集群中通过具体的成员<a href="">名字</a>和<a href="">广播节点URLs</a>:</p><pre><code>$ etcdctl member add infra3 --peer-urls=http://10.0.1.13:2380added member 9bf1b35fc7761a23 to clusterETCD_NAME=&quot;infra3&quot;ETCD_INITIAL_CLUSTER=&quot;infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380,infra3=http://10.0.1.13:2380&quot;ETCD_INITIAL_CLUSTER_STATE=existing</code></pre><p><code>etcdctl</code>已将新成员通知集群，并打印出成功启动集群所需的环境变量。 现在，使用新成员的相关参数启动新的etcd进程：</p><pre><code>$ export ETCD_NAME=&quot;infra3&quot;$ export ETCD_INITIAL_CLUSTER=&quot;infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380,infra3=http://10.0.1.13:2380&quot;$ export ETCD_INITIAL_CLUSTER_STATE=existing$ etcd --listen-client-urls http://10.0.1.13:2379 --advertise-client-urls http://10.0.1.13:2379 --listen-peer-urls http://10.0.1.13:2380 --initial-advertise-peer-urls http://10.0.1.13:2380 --data-dir %data_dir%</code></pre><p>新成员将作为集群的一部分运行，并立即开始同步集群的其余部分。<br>如果添加多个成员，最佳做法是一次配置一个成员，并在添加更多新成员之前验证它是否正确启动.如果将新成员添加到1节点群集中，则群集无法在新成员启动之前取得进展，因为它需要两个成员作为多数才能达成共识。仅在<code>etcdctl``member add</code>通知集群有关新成员的时间和新成员成功建立与现有成员的连接的时间之间，才发生此行为。<br><strong>添加一个新的成员为领导者</strong><br>从v3.4开始，etcd支持将新成员添加为领导者/非投票成员。激励和设计可以在<a href="">设计文档</a>中找到。为了使添加新成员的过程更安全，并减少添加新成员时的集群停机时间.建议将新成员作为学习者添加到集群中，直到同步完成为止。 这可以描述为三步过程：</p><ul><li>通过<a href="">gRPC成员API</a>或者<code>etcdctl member add --learner</code>命令将新成员添加为学习者。</li><li>通过新的集群配置启动新的成员，新的集群配置包括被更新的成员(已存在的成员+新成员)和之前的步骤相同.</li><li>通过<a href="">gRPC成员API</a>或<code>etcdctl member promote</code>命令将新添加的学习者提升为有投票权的成员。etcd服务器验证升级请求以确保其运行安全.只有在其Raft日志达到领导者的水平之后，才能将学习者提升为有投票权的成员。如果学习者成员未赶上领导者的Raft日志，则成员升级请求将失败(见<a href="">提升成员错误案例</a>部分获取更多细节).这种情况下，用户应该等待并重试。</li></ul><p>在v3.4中，etcd服务器将群集可以拥有的学习者数量限制为一个。 主要考虑因素是限制由于领导者向学习者传播数据而导致的领导者额外工作量。<br>使用<code>etcdctl member add</code>和参数<code>--learner</code>添加一个新成员作为学习者到集群中.</p><pre><code>$ etcdctl member add infra3 --peer-urls=http://10.0.1.13:2380 --learnerMember 9bf1b35fc7761a23 added to cluster a7ef944b95711739ETCD_NAME=&quot;infra3&quot;ETCD_INITIAL_CLUSTER=&quot;infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380,infra3=http://10.0.1.13:2380&quot;ETCD_INITIAL_CLUSTER_STATE=existing</code></pre><p>新的etcd程序添加新的学习者成员启动后，使用<code>etcdctl member promote</code>将学习者提升为投票成员。</p><pre><code>$ etcdctl member promote 9bf1b35fc7761a23Member 9e29bbaa45d74461 promoted in cluster a7ef944b95711739</code></pre><p><strong>添加成员错误案例</strong><br>在以下情况下，新主机不包含在枚举节点列表中。 如果这是一个新集群，则必须将该节点添加到初始集群成员列表中。</p><pre><code>$ etcd --name infra3 \  --initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \  --initial-cluster-state existingetcdserver: assign ids error: the member count is unequalexit 1</code></pre><p>在这种情况下，使用了与用于加入集群的地址（10.0.1.13:2380）不同的地址（10.0.1.14:2380）：</p><pre><code>$ etcd --name infra4 \  --initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380,infra4=http://10.0.1.14:2380 \  --initial-cluster-state existingetcdserver: assign ids error: unmatched member while checking PeerURLsexit 1</code></pre><p>如果etcd开始使用已删除成员的数据目录，则etcd如果连接到集群中的任何活动成员，则会自动退出：</p><pre><code>$ etcdetcd: this member has been permanently removed from the cluster. Exiting.exit 1</code></pre><p><strong>添加成员为领导者错误案例</strong><br>当集群中含有一个领导者时不能添加领导者到集群中(v3.4):</p><pre><code>$ etcdctl member add infra4 --peer-urls=http://10.0.1.14:2380 --learnerError: etcdserver: too many learner members in cluster</code></pre><p><strong>提升成员为领导者错误案例</strong><br>如果学习者与领导者同步，则只能被提升为有投票权的成员。</p><pre><code>$ etcdctl member promote 9bf1b35fc7761a23Error: etcdserver: can only promote a learner member which is in sync with leader</code></pre><p>提升不是学习者的成员将失败。</p><pre><code>$ etcdctl member promote 9bf1b35fc7761a23Error: etcdserver: can only promote a learner member</code></pre><p>提升一个集群中不存在的成员将会失败：</p><pre><code>$ etcdctl member promote 12345abcdeError: etcdserver: member not found</code></pre><h3 id="严格的重新配置检查模式-strict-reconfig-check"><a href="#严格的重新配置检查模式-strict-reconfig-check" class="headerlink" title="严格的重新配置检查模式(-strict-reconfig-check)"></a>严格的重新配置检查模式(<code>-strict-reconfig-check</code>)</h3><p>如上所述，添加新成员的最佳实践是一次配置一个成员，并在添加更多新成员之前验证它是否正确启动。这种分步方法非常重要，因为如果未正确配置新添加的成员（例如，对等URL不正确），则群集可能会丢失仲裁。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Blog</title>
    <link href="undefined2019/11/23/hello-world/"/>
    <url>2019/11/23/hello-world/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP_JSON_API通过gRPC网关</title>
    <link href="undefined2019/11/23/blog/etcd/HTTP_JSON_API%E9%80%9A%E8%BF%87gRPC%E7%BD%91%E5%85%B3/"/>
    <url>2019/11/23/blog/etcd/HTTP_JSON_API%E9%80%9A%E8%BF%87gRPC%E7%BD%91%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>etcd v3 使用 gRPC 作为消息协议。etcd项目包括一个基于gRPC的<strong>Go客户端</strong>和一个命令行工具，<strong>etcdctl</strong>,通过gRPC与etcd集群进行交互.对于没有gRPC支持的语言，etcd提供JSON <strong>gRPC网关</strong>，这个网关提供一个RESTful风格的代理可以将HTTP/JSON请求转换为gRPC消息。</p><h3 id="使用-gRPC网关"><a href="#使用-gRPC网关" class="headerlink" title="使用 gRPC网关"></a>使用 gRPC网关</h3><p>这个网关接受一个到etcd’s buffer协议消息定义的JSON格式的映射,注意<code>Key</code>和<code>Value</code>字段定义为byte 数组，因此JSON必须使用base64编码,下面的例子使用<code>curl</code>,但是每个HTTP/JSON客户端的工作原理都和例子相同。<br><strong>注意</strong><br>gRPC网关节点从etcd v3.3发生变化：</p><ul><li>etcd v3.2以及之前版本只使用<code>[CLIENT-URL]/v3alpha/*</code>。</li><li>etcd v3.3使用<code>[CLIENT-URL]/v3beta/*</code>保持<code>[CLIENT-URL]/v3alpha/*</code>使用。</li><li>etcd v3.4使用<code>[CLIENT-URL]/v3/*</code>保持<code>[CLIENT-URL]/v3beta/*</code>使用。<ul><li><code>[CLIENT-URL]/v3alpha/*</code>被抛弃使用。</li></ul></li><li>etcd v3.5以及最新版本只使用<code>[CLIENT-URL]/v3/*</code>。<ul><li><code>[CLIENT-URL]/v3beta/*</code>被抛弃使用。</li></ul></li></ul><h3 id="存储和获取Keys"><a href="#存储和获取Keys" class="headerlink" title="存储和获取Keys"></a>存储和获取Keys</h3><p>使用<code>/v3/kv/range</code>和<code>/v3/kv/put</code>服务读和写Keys:</p><pre><code>&lt;&lt;COMMENThttps://www.base64encode.org/foo is &#39;Zm9v&#39; in Base64bar is &#39;YmFy&#39;COMMENTcurl -L http://localhost:2379/v3/kv/put \  -X POST -d &#39;{&quot;key&quot;: &quot;Zm9v&quot;, &quot;value&quot;: &quot;YmFy&quot;}&#39;# {&quot;header&quot;:{&quot;cluster_id&quot;:&quot;12585971608760269493&quot;,&quot;member_id&quot;:&quot;13847567121247652255&quot;,&quot;revision&quot;:&quot;2&quot;,&quot;raft_term&quot;:&quot;3&quot;}}curl -L http://localhost:2379/v3/kv/range \  -X POST -d &#39;{&quot;key&quot;: &quot;Zm9v&quot;}&#39;# {&quot;header&quot;:{&quot;cluster_id&quot;:&quot;12585971608760269493&quot;,&quot;member_id&quot;:&quot;13847567121247652255&quot;,&quot;revision&quot;:&quot;2&quot;,&quot;raft_term&quot;:&quot;3&quot;},&quot;kvs&quot;:[{&quot;key&quot;:&quot;Zm9v&quot;,&quot;create_revision&quot;:&quot;2&quot;,&quot;mod_revision&quot;:&quot;2&quot;,&quot;version&quot;:&quot;1&quot;,&quot;value&quot;:&quot;YmFy&quot;}],&quot;count&quot;:&quot;1&quot;}# get all keys prefixed with &quot;foo&quot;curl -L http://localhost:2379/v3/kv/range \  -X POST -d &#39;{&quot;key&quot;: &quot;Zm9v&quot;, &quot;range_end&quot;: &quot;Zm9w&quot;}&#39;# {&quot;header&quot;:{&quot;cluster_id&quot;:&quot;12585971608760269493&quot;,&quot;member_id&quot;:&quot;13847567121247652255&quot;,&quot;revision&quot;:&quot;2&quot;,&quot;raft_term&quot;:&quot;3&quot;},&quot;kvs&quot;:[{&quot;key&quot;:&quot;Zm9v&quot;,&quot;create_revision&quot;:&quot;2&quot;,&quot;mod_revision&quot;:&quot;2&quot;,&quot;version&quot;:&quot;1&quot;,&quot;value&quot;:&quot;YmFy&quot;}],&quot;count&quot;:&quot;1&quot;}</code></pre><h3 id="查看-Keys"><a href="#查看-Keys" class="headerlink" title="查看 Keys"></a>查看 Keys</h3><p>使用<code>/v3/watch</code>服务查看Keys:</p><pre><code>curl -N http://localhost:2379/v3/watch \  -X POST -d &#39;{&quot;create_request&quot;: {&quot;key&quot;:&quot;Zm9v&quot;} }&#39; &amp;# {&quot;result&quot;:{&quot;header&quot;:{&quot;cluster_id&quot;:&quot;12585971608760269493&quot;,&quot;member_id&quot;:&quot;13847567121247652255&quot;,&quot;revision&quot;:&quot;1&quot;,&quot;raft_term&quot;:&quot;2&quot;},&quot;created&quot;:true}}curl -L http://localhost:2379/v3/kv/put \  -X POST -d &#39;{&quot;key&quot;: &quot;Zm9v&quot;, &quot;value&quot;: &quot;YmFy&quot;}&#39; &gt;/dev/null 2&gt;&amp;1# {&quot;result&quot;:{&quot;header&quot;:{&quot;cluster_id&quot;:&quot;12585971608760269493&quot;,&quot;member_id&quot;:&quot;13847567121247652255&quot;,&quot;revision&quot;:&quot;2&quot;,&quot;raft_term&quot;:&quot;2&quot;},&quot;events&quot;:[{&quot;kv&quot;:{&quot;key&quot;:&quot;Zm9v&quot;,&quot;create_revision&quot;:&quot;2&quot;,&quot;mod_revision&quot;:&quot;2&quot;,&quot;version&quot;:&quot;1&quot;,&quot;value&quot;:&quot;YmFy&quot;}}]}}</code></pre><h3 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h3><p>使用``/v3/kv/txn`发行一个交易：</p><pre><code># 目标创建curl -L http://localhost:2379/v3/kv/txn \  -X POST \  -d &#39;{&quot;compare&quot;:[{&quot;target&quot;:&quot;CREATE&quot;,&quot;key&quot;:&quot;Zm9v&quot;,&quot;createRevision&quot;:&quot;2&quot;}],&quot;success&quot;:[{&quot;requestPut&quot;:{&quot;key&quot;:&quot;Zm9v&quot;,&quot;value&quot;:&quot;YmFy&quot;}}]}&#39;# {&quot;header&quot;:{&quot;cluster_id&quot;:&quot;12585971608760269493&quot;,&quot;member_id&quot;:&quot;13847567121247652255&quot;,&quot;revision&quot;:&quot;3&quot;,&quot;raft_term&quot;:&quot;2&quot;},&quot;succeeded&quot;:true,&quot;responses&quot;:[{&quot;response_put&quot;:{&quot;header&quot;:{&quot;revision&quot;:&quot;3&quot;}}}]}</code></pre><pre><code># 目标版本curl -L http://localhost:2379/v3/kv/txn \  -X POST \  -d &#39;{&quot;compare&quot;:[{&quot;version&quot;:&quot;4&quot;,&quot;result&quot;:&quot;EQUAL&quot;,&quot;target&quot;:&quot;VERSION&quot;,&quot;key&quot;:&quot;Zm9v&quot;}],&quot;success&quot;:[{&quot;requestRange&quot;:{&quot;key&quot;:&quot;Zm9v&quot;}}]}&#39;# {&quot;header&quot;:{&quot;cluster_id&quot;:&quot;14841639068965178418&quot;,&quot;member_id&quot;:&quot;10276657743932975437&quot;,&quot;revision&quot;:&quot;6&quot;,&quot;raft_term&quot;:&quot;3&quot;},&quot;succeeded&quot;:true,&quot;responses&quot;:[{&quot;response_range&quot;:{&quot;header&quot;:{&quot;revision&quot;:&quot;6&quot;},&quot;kvs&quot;:[{&quot;key&quot;:&quot;Zm9v&quot;,&quot;create_revision&quot;:&quot;2&quot;,&quot;mod_revision&quot;:&quot;6&quot;,&quot;version&quot;:&quot;4&quot;,&quot;value&quot;:&quot;YmF6&quot;}],&quot;count&quot;:&quot;1&quot;}}]}</code></pre><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>使用<code>/v3/auth</code>设置权限：</p><pre><code># 创建root用户curl -L http://localhost:2379/v3/auth/user/add \  -X POST -d &#39;{&quot;name&quot;: &quot;root&quot;, &quot;password&quot;: &quot;pass&quot;}&#39;# {&quot;header&quot;:{&quot;cluster_id&quot;:&quot;14841639068965178418&quot;,&quot;member_id&quot;:&quot;10276657743932975437&quot;,&quot;revision&quot;:&quot;1&quot;,&quot;raft_term&quot;:&quot;2&quot;}}# 创建root角色curl -L http://localhost:2379/v3/auth/role/add \  -X POST -d &#39;{&quot;name&quot;: &quot;root&quot;}&#39;# {&quot;header&quot;:{&quot;cluster_id&quot;:&quot;14841639068965178418&quot;,&quot;member_id&quot;:&quot;10276657743932975437&quot;,&quot;revision&quot;:&quot;1&quot;,&quot;raft_term&quot;:&quot;2&quot;}}# 授予root角色curl -L http://localhost:2379/v3/auth/user/grant \  -X POST -d &#39;{&quot;user&quot;: &quot;root&quot;, &quot;role&quot;: &quot;root&quot;}&#39;# {&quot;header&quot;:{&quot;cluster_id&quot;:&quot;14841639068965178418&quot;,&quot;member_id&quot;:&quot;10276657743932975437&quot;,&quot;revision&quot;:&quot;1&quot;,&quot;raft_term&quot;:&quot;2&quot;}}# 开启认证curl -L http://localhost:2379/v3/auth/enable -X POST -d &#39;{}&#39;# {&quot;header&quot;:{&quot;cluster_id&quot;:&quot;14841639068965178418&quot;,&quot;member_id&quot;:&quot;10276657743932975437&quot;,&quot;revision&quot;:&quot;1&quot;,&quot;raft_term&quot;:&quot;2&quot;}}</code></pre><p>通过<code>/v3/auth/authenticate</code>服务使用一个认证令牌进行认证:</p><pre><code># 为根用户获取认证令牌curl -L http://localhost:2379/v3/auth/authenticate \  -X POST -d &#39;{&quot;name&quot;: &quot;root&quot;, &quot;password&quot;: &quot;pass&quot;}&#39;# {&quot;header&quot;:{&quot;cluster_id&quot;:&quot;14841639068965178418&quot;,&quot;member_id&quot;:&quot;10276657743932975437&quot;,&quot;revision&quot;:&quot;1&quot;,&quot;raft_term&quot;:&quot;2&quot;},&quot;token&quot;:&quot;sssvIpwfnLAcWAQH.9&quot;}</code></pre><p>使用认证证书设置认证头部到认证令牌获取Keys：</p><pre><code>curl -L http://localhost:2379/v3/kv/put \  -H &#39;Authorization : sssvIpwfnLAcWAQH.9&#39; \  -X POST -d &#39;{&quot;key&quot;: &quot;Zm9v&quot;, &quot;value&quot;: &quot;YmFy&quot;}&#39;# {&quot;header&quot;:{&quot;cluster_id&quot;:&quot;14841639068965178418&quot;,&quot;member_id&quot;:&quot;10276657743932975437&quot;,&quot;revision&quot;:&quot;2&quot;,&quot;raft_term&quot;:&quot;2&quot;}}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gRPC命名与发现</title>
    <link href="undefined2019/11/23/blog/etcd/gRPC%E5%91%BD%E5%90%8D%E4%B8%8E%E5%8F%91%E7%8E%B0/"/>
    <url>2019/11/23/blog/etcd/gRPC%E5%91%BD%E5%90%8D%E4%B8%8E%E5%8F%91%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>etcd提供一个gRPC解析器支持备用的命名系统，该命名系统从etcd获取主机以发现gRPC服务。以下机制基于监视对以服务名称为前缀的Key的更新。<br>通过go-grpc使用etcd发现服务</p><hr><p>etcd客户端提供一个gRPC解析器通过etcd后端解析gRPC主机,解析器通过etcd客户端初始化并指定了解析目标:</p><pre><code>import (        &quot;go.etcd.io/etcd/clientv3&quot;        etcdnaming &quot;go.etcd.io/etcd/clientv3/naming&quot;        &quot;google.golang.org/grpc&quot;)...cli, cerr := clientv3.NewFromURL(&quot;http://localhost:2379&quot;)r := &amp;etcdnaming.GRPCResolver{Client: cli}b := grpc.RoundRobin(r)conn, gerr := grpc.Dial(&quot;my-service&quot;, grpc.WithBalancer(b), grpc.WithBlock(), ...)</code></pre><h3 id="管理服务主机"><a href="#管理服务主机" class="headerlink" title="管理服务主机"></a>管理服务主机</h3><p>etcd解析器对于解析目标前缀下所有Keys后面跟一个”/“(例如”my-service/“),使用JSON编码go-grpc<code>naming.Update</code>值作为潜在的服务主机。通过创建一个新的Key将主机添加到服务中，通过删除Keys将主机从服务中删除。</p><h3 id="添加一个主机"><a href="#添加一个主机" class="headerlink" title="添加一个主机"></a>添加一个主机</h3><p>一个新的主机可以通过<code>etcdctl</code>添加到服务中：</p><pre><code>ETCDCTL_API=3 etcdctl put my-service/1.2.3.4 &#39;{&quot;Addr&quot;:&quot;1.2.3.4&quot;,&quot;Metadata&quot;:&quot;...&quot;}&#39;</code></pre><p>etcd客户端的<code>GRPCResolver.Update</code>方法也可以通过key匹配<code>Addr</code>注册一个新的主机到服务中：</p><pre><code>r.Update(context.TODO(), &quot;my-service&quot;, naming.Update{Op: naming.Add, Addr: &quot;1.2.3.4&quot;, Metadata: &quot;...&quot;})</code></pre><h3 id="删除一个主机"><a href="#删除一个主机" class="headerlink" title="删除一个主机"></a>删除一个主机</h3><p>通过etcdctl可以从服务中删除一个主机:</p><pre><code>ETCDCTL_API=3 etcdctl del my-service/1.2.3.4</code></pre><p>etcd 客户端的<code>GRPCResolver.Update</code>方法也可以删除一个主机：</p><pre><code>r.Update(context.TODO(), &quot;my-service&quot;, naming.Update{Op: naming.Delete, Addr: &quot;1.2.3.4&quot;})</code></pre><h3 id="注册一个主机并绑定一个租约"><a href="#注册一个主机并绑定一个租约" class="headerlink" title="注册一个主机并绑定一个租约"></a>注册一个主机并绑定一个租约</h3><p>注册一个主机ging绑定一个租约确保如果主机不能维护保持存活的心跳(例如机器宕机)，该主机将会从服务中移除。</p><pre><code>lease=`ETCDCTL_API=3 etcdctl lease grant 5 | cut -f2 -d&#39; &#39;`ETCDCTL_API=3 etcdctl put --lease=$lease my-service/1.2.3.4 &#39;{&quot;Addr&quot;:&quot;1.2.3.4&quot;,&quot;Metadata&quot;:&quot;...&quot;}&#39;ETCDCTL_API=3 etcdctl lease keep-alive $lease</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运行时重新配置设计</title>
    <link href="undefined2019/11/23/blog/etcd/%E8%BF%90%E8%A1%8C%E6%97%B6%E9%87%8D%E6%96%B0%E9%85%8D%E7%BD%AE%E8%AE%BE%E8%AE%A1/"/>
    <url>2019/11/23/blog/etcd/%E8%BF%90%E8%A1%8C%E6%97%B6%E9%87%8D%E6%96%B0%E9%85%8D%E7%BD%AE%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>运行时重新配置是分布式系统中最难，最容易出错的部分，尤其是在基于共识(像etcd)的系统中。<br>阅读并学习关于etcd的运行时重新配置命令设计和如何追溯这些错误.</p><h3 id="两阶段配置更新保证集群安全"><a href="#两阶段配置更新保证集群安全" class="headerlink" title="两阶段配置更新保证集群安全"></a>两阶段配置更新保证集群安全</h3><hr><p>在etcd中，每一次运行时重新配置安全的原因是由于两阶段更新。例如，添加一个成员，首先将新配置通知集群后启动新的成员。</p><ol><li>阶段一 通知集群关于新的配置<br>添加一个成员到etcd集群中，通过API调用请求将一个新成员添加到集群中。这是将新的成员添加到集群中唯一的方法。当集群同意配置的更新后将返回API的调用。</li><li>阶段二 启动一个新的成员<br>将一个新成员加入到存在的集群中，指定正确的<code>initial-cluster</code>和设置<code>initial-cluster-state</code>为<code>existing</code>.当成员启动后，它首先联系已存在的集群并验证当前集群配置是否和期望的<code>initial-cluster</code>匹配。当一个新的成员成功启动，集群将获得期望的配置。</li></ol><p>用户将过程分为两个阶段需要清楚了解集群成员关系的变化。实际上，这为用户提供了更大的灵活性，并使事情更容易。例如，如果试图添加一个与集群中现有的成员Id相同的新成员到集群中，操作将会立即失败由于阶段一并没有影响到运行中的集群。提供了类似的保护阻止通过错误操作添加新的成员。如果一个新的etcd成员试图在集群接受配置信息更新之前加入集群，操作将不会被集群接受。</p><p>如果没有围绕集群成员关系的显式工作流，集群将会容易受到意料之外的集群成员关系变化的影响。例如，如果etcd在一个初始化的系统如systemd中运行，etcd将会通过成员关系API在重新启动之后被移除，并试图在启动后重新加入。这个循环将会在每次通过API成员移除并将系统设置为失败后重新启动etcd时继续，这是预料之外的。</p><p>我们希望运行时重新进行配置是不常见的操作。我们决定保持为显式的由用户驱动来确保配置安全，保持集群平稳运行在显式的控制下。</p><h3 id="永久性的丢失要求新的集群"><a href="#永久性的丢失要求新的集群" class="headerlink" title="永久性的丢失要求新的集群"></a>永久性的丢失要求新的集群</h3><hr><p>如果一个集群永久丢失一些主要的集群成员，需要从原始的数据文件夹启动一个新的集群恢复先前的状态。</p><p>完全有可能从已存在的集群中强制删除一个失败的成员并恢复。然而，我们决定不支持此方法因为他绕过了常规的共识提交阶段，这是不安全的。如果成员移除一个没有实际失败的成员或者是同一个集群中的不同成员，etcd将会最终得到具有相同集群Id的分散集群。这是非常危险的而且很难修复。</p><p>通过正常的部署，永久性丢失的可能性非常的小。但是这是一个严重的问题值得特别注意。我们强烈建议阅读<strong>灾难恢复文档</strong>并且在将etcd部署到生产环境之前做充足的准备。</p><h3 id="不要在运行时重新配置中使用公共的发现服务"><a href="#不要在运行时重新配置中使用公共的发现服务" class="headerlink" title="不要在运行时重新配置中使用公共的发现服务"></a>不要在运行时重新配置中使用公共的发现服务</h3><hr><p>公共发现服务应该只在启动一个集群的时候使用。将一个成员加入已存在的集群，使用运行时配置API.</p><p>发现服务被设计用来在云服务环境中启动一个在所有的成员无法提前知道Ip地址时的etcd集群。在成功启动一个集群时，所有的成员将会知道Ip地址。典型的，发现服务奖不再被需要。<br>看起来使用公共的发现服务进行运行时重新配置是一个便利的方法,毕竟所有的发现服务含有所有的集群配置信息。然而依赖公共发现服务将带来问题：</p><ol><li>将会引进外部独立性到集群的整个生命周期，不只是启动时间。如果集群和公共发现服务之间存在网络问题，则群集将因此受到影响。</li><li>公共发现服务必须在集群的生命周期内反映正确的运行时配置，将需要提供安全机制避免坏的行为，而这是困难的。</li><li>公共发现服务需要保持数万个集群的配置，而我们的公共发现服务很难承受这种负载。</li></ol><p>为了使发现服务支持运行时配置，最好的选择是建立一个私有的发现服务。</p>]]></content>
    
    
    
    <tags>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>与etcd进行交互</title>
    <link href="undefined2019/11/23/blog/etcd/%E4%B8%8Eetcd%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92/"/>
    <url>2019/11/23/blog/etcd/%E4%B8%8Eetcd%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92/</url>
    
    <content type="html"><![CDATA[<h2 id="与etcd进行交互"><a href="#与etcd进行交互" class="headerlink" title="与etcd进行交互"></a>与etcd进行交互</h2><p>用户更多的是通过putting或者是getting从etcd获取一个键对应的值。这一部分描述了如何通过etcdctl做这些工作。etcdctl是一个与etcd服务器进行交互的命令行工具.这里的描述适用于gRPC APIs或者是客户端库的APIs。<br>用于与etcd交互的API版本可以通过环境变量<code>ETCDCTL_API</code>设置为2或者3.默认情况下，分支为(3.4)的主版本使用V3 的API，而早期的版本(3.3或者更早)默认使用V2 API。<br>注意使用V2 API所创建的任何Key不能够通过V3 API进行访问。而V3 API <code>etcdctl get</code>获取V2 的Key将返回0并退出，这是预料之中的情况。</p><pre><code>export ETCDCTL_API=3</code></pre><h3 id="发现版本"><a href="#发现版本" class="headerlink" title="发现版本"></a>发现版本</h3><p>使用合适的命令在执行不同版本的etcd时etcdctl和服务器API的版本将会有用。<br>这里的命令可用于发现版本信息：</p><pre><code>$ etcdctl versionetcdctl version:3.1.0-alpha.0+gitAPI version:3.1</code></pre><h3 id="写入一个KEY"><a href="#写入一个KEY" class="headerlink" title="写入一个KEY"></a>写入一个KEY</h3><p>应用程序通过向etcd集群写入Keys来存储Keys，每次存储的Key将会通过Raft协议实现一致性与可扩展性复制到所有的etcd集群成员中。<br>这里的命令是将Key<code>foo</code>的值存储到<code>bar</code>上：</p><pre><code>$ etcdctl put foo barOK</code></pre><p>给Key附上一个租约，Key将在一个具体的时间间隔被设置。<br>这里的命令是在10秒后将Key<code>foo</code>的值存储到<code>bar</code>上：</p><pre><code>$ etcdctl put foo1 bar1 --lease=1234abcd</code></pre><p>注意：以上命令中租约ID为1234abcd将会在租约创建10秒后将id返回，这个id将附在Key上。</p><h3 id="读取Keys"><a href="#读取Keys" class="headerlink" title="读取Keys"></a>读取Keys</h3><p>应用程序可以从一个etcd集群中读取Key，可能会查询到单个Key，或者是一个范围内的Key。<br>比如etcd集群中存储以下Key：</p><pre><code>foo = barfoo1 = bar1foo2 = bar2foo3 = bar3</code></pre><p>这里的命令是读取Key<code>foo</code>对应的值：</p><pre><code>$ etcdctl get foofoobar</code></pre><p>这里的命令是读取Key<code>foo</code>对应的十六进制的值:</p><pre><code>$ etcdctl get foo --hex\x66\x6f\x6f       #Key\x62\x61\x72       #Value</code></pre><p>这里的命令是只读取Key<code>foo</code>对应的值：</p><pre><code>$ etcdctl get foo --print-value-onlybar</code></pre><p>这里的命令是读取从Key<code>foo</code>到Key<code>foo3</code>范围内对应的值：</p><pre><code>$ etcdctl get foo foo3foobarfoo1bar1foo2bar2</code></pre><p>注意这里Key为<code>foo3</code>不包括在内因为这里的范围是半开区间<code>[foo,foo3)</code>，不包括<code>foo3</code>。</p><p>这里的命令是获取前缀为<code>foo</code>的Key的范围内所有的值：</p><pre><code>$ etcdctl get --prefix foofoobarfoo1bar1foo2bar2foo3bar3</code></pre><p>这里的命令是获取前缀为<code>foo</code>的Key的范围内所有的值,并且限制结果集为2：</p><pre><code>$ etcdctl get --prefix --limit=2 foofoobarfoo1bar1</code></pre><h3 id="读取之前版本的Keys："><a href="#读取之前版本的Keys：" class="headerlink" title="读取之前版本的Keys："></a>读取之前版本的Keys：</h3><p>应用程度可能希望读取一个被替代的版本的Key。例如，一个应用程序可能想要通过读取一个先前版本的Key来回滚到一个老的配置。另外，一个应用程序可能想要通过访问Key的历史记录对多个Key通过多个请求获取一致性的结果。由于对etcd集群中键值对的每一次修改都会增加对在etcd集群中的全局修订存储，应用程序可以通过提供一个老的版本来读取被替代的Keys。<br>比如一个etcd集群中存在以下的Keys：</p><pre><code>foo = bar         # revision = 2foo1 = bar1       # revision = 3foo = bar_new     # revision = 4foo1 = bar1_new   # revision = 5</code></pre><p>这里的例子是访问过去版本的Keys：</p><pre><code>$ etcdctl get --prefix foo # access the most recent versions of keysfoobar_newfoo1bar1_new$ etcdctl get --prefix --rev=4 foo # access the versions of keys at revision 4foobar_newfoo1bar1$ etcdctl get --prefix --rev=3 foo # access the versions of keys at revision 3foobarfoo1bar1$ etcdctl get --prefix --rev=2 foo # access the versions of keys at revision 2foobar$ etcdctl get --prefix --rev=1 foo # access the versions of keys at revision 1</code></pre><h3 id="读取大于或等于一个具体的Key的比特值的Key："><a href="#读取大于或等于一个具体的Key的比特值的Key：" class="headerlink" title="读取大于或等于一个具体的Key的比特值的Key："></a>读取大于或等于一个具体的Key的比特值的Key：</h3><p>应用程序可能想要读取大于或等于一个具体的Key的byte值的Key。<br>一个etcd集群中有以下的Keys：</p><pre><code>a = 123b = 456z = 789</code></pre><p>这里的命令是读取大于或等于Key <code>b</code>的byte值的Key：</p><pre><code>$ etcdctl get --from-key bb456z789</code></pre><h3 id="删除-Keys"><a href="#删除-Keys" class="headerlink" title="删除 Keys"></a>删除 Keys</h3><p>应用程序可以从etcd集群中删除一个Key或者删除一个范围内的Key：<br>一个etcd集群中有以下的Keys：</p><pre><code>foo = barfoo1 = bar1foo3 = bar3zoo = valzoo1 = val1zoo2 = val2a = 123b = 456z = 789</code></pre><p>这里的命令是删除Key<code>foo</code>:</p><pre><code>$ etcdctl del foo1 # 1 个 key 被删除</code></pre><p>这里的命令是删除从Key<code>foo</code>到Key<code>foo9</code>范围内的Key:</p><pre><code>$ etcdctl del foo foo92 # 2 个 keys 被删除</code></pre><p>这里的命令是删除Key<code>zoo</code>并将已删除的键值对返回:</p><pre><code>$ etcdctl del --prev-kv zoo1   # 1 个 key 被删除zoo # 被删除的Keyval # 被删除的Key所对应的Value</code></pre><p>这里的命令是删除前缀为<code>zoo</code>的Keys:</p><pre><code>$ etcdctl del --prefix zoo2 # 2 个 key 被删除</code></pre><p>这里的命令是读取大于或等于Key <code>b</code>的byte值的Keys：</p><pre><code>$ etcdctl del --from-key b2 # 2 个 key 被删除</code></pre><h3 id="观察key的变化"><a href="#观察key的变化" class="headerlink" title="观察key的变化"></a>观察key的变化</h3><p>应用程序可以监视一个Key或者一个范围内的Keys的每一次更新。<br>这里的命令是观察key<code>foo</code>:</p><pre><code>$ etcdctl watch foo# 在另一个终端执行: etcdctl put foo barPUTfoobar</code></pre><p>这里的命令是观察十六进制的key<code>foo</code>:</p><pre><code>$ etcdctl watch foo --hex# 在另一个终端执行: etcdctl put foo barPUT\x66\x6f\x6f          # Key\x62\x61\x72          # Value</code></pre><p>这里的命令是观察从Key<code>foo</code>到Key<code>foo9</code>范围内的Key：</p><pre><code>$ etcdctl watch foo foo9# 在另一个终端执行: etcdctl put foo barPUTfoobar# 在另一个终端执行: etcdctl put foo1 bar1PUTfoo1bar1</code></pre><p>这里的命令是观察前缀为<code>foo</code>的Key的范围内所有的值：</p><pre><code>$ etcdctl watch --prefix foo# 在另一个终端执行: etcdctl put foo barPUTfoobar# 在另一个终端执行: etcdctl put fooz1 barz1PUTfooz1barz1</code></pre><p>这里的命令是观察多个Keys<code>foo</code>和<code>zoo</code>:</p><pre><code>$ etcdctl watch -i$ watch foo$ watch zoo# 在另一个终端执行: etcdctl put foo barPUTfoobar# 在另一个终端执行: etcdctl put zoo valPUTzooval</code></pre><h3 id="观察Keys的历史版本"><a href="#观察Keys的历史版本" class="headerlink" title="观察Keys的历史版本"></a>观察Keys的历史版本</h3><p>应用程序可能想要观察etcd中Keys的更新历史。例如，应用程序可能想获取key的所有修改；如果应用程序保持与etcd的连接，那么命令<code>watch</code>已经足够。然而，如果应用程序或者etcd宕机，一次更新可能就会失败，应用程序可能不能实时接收Key的更新。为了保证更新可以被交付，应用程序必须通过观察到Keys的历史更新。为了做到这些，应用程序要指定观察的历史版本，就像读取历史版本的Keys：<br>我们首先完成以下操作：</p><pre><code>$ etcdctl put foo bar         # revision = 2OK$ etcdctl put foo1 bar1       # revision = 3OK$ etcdctl put foo bar_new     # revision = 4OK$ etcdctl put foo1 bar1_new   # revision = 5OK</code></pre><p>这里有个例子观察历史更新：</p><pre><code># watch for changes on key `foo` since revision 2$ etcdctl watch --rev=2 fooPUTfoobarPUTfoobar_new</code></pre><pre><code># watch for changes on key `foo` since revision 3$ etcdctl watch --rev=3 fooPUTfoobar_new</code></pre><p>这里有例子只观察最后一次的更新：</p><pre><code># watch for changes on key `foo` and return last revision value along with modified value$ etcdctl watch --prev-kv foo# 在另一个终端执行 etcdctl put foo bar_latestPUTfoo         # keybar_new     # last value of foo key before modificationfoo         # keybar_latest  # value of foo key after modification</code></pre><h3 id="观察进度"><a href="#观察进度" class="headerlink" title="观察进度"></a>观察进度</h3><p>应用程序可能想要检查观察者进度以确定最新的观察者流的状态。例如，如果观察者更新的缓存，那么就可以通过原子读取与修改进度进行比较知道缓存内容是否已经过时。<br>进度请求可以通过<code>progress</code>命令与观察者session进行交互在一个观察者流中告诉服务器发送一个进度提示更新.</p><pre><code>$ etcdctl watch -i$ watch a$ progressprogress notify: 1# 在另一个终端执行: etcdctl put x 0# 在另一个终端执行: etcdctl put y 1$ progressprogress notify: 3</code></pre><p>注意，在进度提示响应中的修改号来自观察者流连接到的本地etcd服务器。如果该节点被分区并且不是该分区的一部分，这个进度提示修改版本可能会低于由未分区的etcd服务器节点返回的修改版本。</p><h3 id="压缩修改"><a href="#压缩修改" class="headerlink" title="压缩修改"></a>压缩修改</h3><p>正如我们提到的，etcd保持修改信息所以应用可以读取过去版本的Keys，然而，为了避免无数的修改历史累积，对过去的修改进行压缩是很重要的。在压缩后，etcd移除了历史修改，释放资源为以后使用。在压缩修改版本之前所有的被修改的替代版本数据将不能获取。<br>这里的命令是对修改进行压缩：</p><pre><code>$ etcdctl compact 5compacted revision 5# any revisions before the compacted one are not accessible$ etcdctl get --rev=4 fooError:  rpc error: code = 11 desc = etcdserver: mvcc: required revision has been compacted</code></pre><p>注意：etcd服务器的当前版本可以使用json格式的命令通过(存在或不存在的)key发现。例如下面的通过查看在etcd服务器中不存在的myKey:</p><pre><code>$ etcdctl get mykey -w=json{&quot;header&quot;:{&quot;cluster_id&quot;:14841639068965178418,&quot;member_id&quot;:10276657743932975437,&quot;revision&quot;:15,&quot;raft_term&quot;:4}}</code></pre><h3 id="授予租约"><a href="#授予租约" class="headerlink" title="授予租约"></a>授予租约</h3><p>应用程序可以为etcd集群上的Keys授予一个租约。当Key附上租约后，它的生命周期会绑定到租约的生命周期并由存活时间(TTL)进行管理。每一个租约都有一个由应用程序授予的最小的TTL值.这个租约实际的TTL值至少是最小的TTL值，由etcd集群决定。一旦超过租约的TTL，租约将会超时并删除附上的所有的Keys。<br>这里有命令授予一个租约：</p><pre><code># grant a lease with 60 second TTL$ etcdctl lease grant 60lease 32695410dcc0ca06 granted with TTL(60s)# attach key foo to lease 32695410dcc0ca06$ etcdctl put --lease=32695410dcc0ca06 foo barOK</code></pre><h3 id="撤销租约"><a href="#撤销租约" class="headerlink" title="撤销租约"></a>撤销租约</h3><p>应用程序可以根据租约ID撤销租约，撤销一个租约将删除附上的所有的Keys。<br>例如我们完成下面的操作：</p><pre><code>$ etcdctl lease grant 60lease 32695410dcc0ca06 granted with TTL(60s)$ etcdctl put --lease=32695410dcc0ca06 foo barOK</code></pre><p>这里的命令可以撤销该租约：</p><pre><code>$ etcdctl lease revoke 32695410dcc0ca06lease 32695410dcc0ca06 revoked$ etcdctl get foo# empty response since foo is deleted due to lease revocation</code></pre><h3 id="保持租约存活"><a href="#保持租约存活" class="headerlink" title="保持租约存活"></a>保持租约存活</h3><p>应用程序可以通过刷新租约的TTL使它不会超时保证租约存活。<br>例如我们完成下面的操作：</p><pre><code>$ etcdctl lease grant 60lease 32695410dcc0ca06 granted with TTL(60s)</code></pre><p>这里有命令保持租约存活：</p><pre><code>$ etcdctl lease keep-alive 32695410dcc0ca06lease 32695410dcc0ca06 keepalived with TTL(60)lease 32695410dcc0ca06 keepalived with TTL(60)lease 32695410dcc0ca06 keepalived with TTL(60)...</code></pre><h3 id="获取租约信息"><a href="#获取租约信息" class="headerlink" title="获取租约信息"></a>获取租约信息</h3><p>应用程序可能想知道关于租约的信息，所以可以通过重新创建或者检查租约是否仍然生存或已经超时。应用程序可能也想知道一个具体的租约上所附的Key。<br>例如我们完成下面的操作：</p><pre><code># grant a lease with 500 second TTL$ etcdctl lease grant 500lease 694d5765fc71500b granted with TTL(500s)# attach key zoo1 to lease 694d5765fc71500b$ etcdctl put zoo1 val1 --lease=694d5765fc71500bOK# attach key zoo2 to lease 694d5765fc71500b$ etcdctl put zoo2 val2 --lease=694d5765fc71500bOK</code></pre><p>这里有命令获取关于租约的信息:</p><pre><code>$ etcdctl lease timetolive 694d5765fc71500blease 694d5765fc71500b granted with TTL(500s), remaining(258s)</code></pre><p>这里有命令获取租约上所依附的关于Keys的信息：</p><pre><code>$ etcdctl lease timetolive --keys 694d5765fc71500blease 694d5765fc71500b granted with TTL(500s), remaining(132s), attached keys([zoo2 zoo1])# if the lease has expired or does not exist it will give the below response:Error:  etcdserver: requested lease not found</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>客户端v3</title>
    <link href="undefined2019/11/23/blog/etcd/%E5%AE%A2%E6%88%B7%E7%AB%AFv3/"/>
    <url>2019/11/23/blog/etcd/%E5%AE%A2%E6%88%B7%E7%AB%AFv3/</url>
    
    <content type="html"><![CDATA[<p><code>etcd/clientv3</code>是v3版本的Go etcd官方客户端</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><hr><pre><code>go get go.etcd.io/etcd/clientv3</code></pre><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><hr><p>创建客户端使用<code>clientv3.New</code>:</p><pre><code>cli, err := clientv3.New(clientv3.Config{    Endpoints:   []string{&quot;localhost:2379&quot;, &quot;localhost:22379&quot;, &quot;localhost:32379&quot;},    DialTimeout: 5 * time.Second,})if err != nil {    // handle error!}defer cli.Close()</code></pre><p>etcd v3使用<code>gRPC</code>进行远程程序调用，并且<code>clientv3</code>使用<code>grpc-go</code>连接etcd。确保在使用完客户端后关闭它，如果客户端没有关闭，连接将会有泄漏的<code>goroutines</code>。指定超时时间，通过<code>context.WithTimeout</code>使用APIs:</p><pre><code>ctx, cancel := context.WithTimeout(context.Background(), timeout)resp, err := cli.Put(ctx, &quot;sample_key&quot;, &quot;sample_value&quot;)cancel()if err != nil {    // handle error!}// use the response</code></pre><p>为了完全兼容，建议使用etcd’s中的vendored包进行构建，使用工具像<code>golang/dep</code>,在vendor目录内。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>etcd客户端返回两种类型的错误：</p><ol><li>context error :canceled or deadline exceeded.</li><li>gRpc error : 看api/v3rpc/rpctypes.</li></ol><p>这里有例子处理客户端错误：</p><pre><code>resp, err := cli.Put(ctx, &quot;&quot;, &quot;&quot;)if err != nil {    switch err {    case context.Canceled:        log.Fatalf(&quot;ctx is canceled by another routine: %v&quot;, err)    case context.DeadlineExceeded:        log.Fatalf(&quot;ctx is attached with a deadline is exceeded: %v&quot;, err)    case rpctypes.ErrEmptyKey:        log.Fatalf(&quot;client-side error: %v&quot;, err)    default:        log.Fatalf(&quot;bad cluster endpoints, which are not etcd servers: %v&quot;, err)    }}</code></pre><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>etcd客户端可以通过<strong>go-grpc-prometheus</strong>,选择RPC监控指标,看<strong>例子</strong>。</p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p><strong>namespace</strong>包提供<code>clientv3</code>接口封装透明隔离客户端请求到用户定义的前缀。</p><h2 id="请求大小限制"><a href="#请求大小限制" class="headerlink" title="请求大小限制"></a>请求大小限制</h2><p>客户端请求大小限制通过<code>clientv3.Config.MaxCallSendMsgSize</code>和<code>MaxCallRecvMsgSize</code>进行配置。如果没有给予值，客户端请求发送限制包括gRPC负载默认2MB。接收限制默认为<code>math.MaxInt32</code>。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>更多代码例子可以从<strong>GoDoc</strong>发现。</p>]]></content>
    
    
    
    <tags>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多机集群</title>
    <link href="undefined2019/11/23/blog/etcd/%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/"/>
    <url>2019/11/23/blog/etcd/%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><hr><p>启动一个集群静态的要求是每一个集群中的成员需要知道其他成员的位置。在许多情况下，集群成员的IP可能无法提前知道。在这种情况下，etcd集群可以在发现服务的帮助下进行启动。<br>一旦etcd集群已经启动，添加或移除成员可以通过<a href="运行时重新配置.md">运行时重新配置</a>。在运行时重新配置之前，为了更好地理解设计，我们建议读<a href="运行时重新配置设计.md">运行时重新配置设计文档</a>。<br>这篇引导etcd集群的启动将包括以下机制：</p><ul><li><strong>静态</strong></li><li><strong>etcd发现</strong></li><li><strong>DNS发现</strong></li></ul><p>每种引导机制都将用于创建具有以下详细信息的三台计算机etcd集群：</p><table><thead><tr><th>Name</th><th>Address</th><th>Hostname</th></tr></thead><tbody><tr><td>infra0</td><td>10.0.1.10</td><td>infra0.example.com</td></tr><tr><td>infra1</td><td>10.0.1.11</td><td>infra1.example.com</td></tr><tr><td>infra2</td><td>10.0.1.12</td><td>infra2.example.com</td></tr></tbody></table><h2 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h2><p>集群的成员，在启动之前它们的地址和集群的大小，我们可以通过设置<code>initial-cluster</code>参数使用离线的启动配置。每一个机器将会通过以下的环境变量或命令行获得配置信息：</p><pre><code>ETCD_INITIAL_CLUSTER=&quot;infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380&quot;ETCD_INITIAL_CLUSTER_STATE=new</code></pre><pre><code>--initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \--initial-cluster-state new</code></pre><p>注意在<code>initial-cluster</code>中的URLs必须是已发布的对等的节点的URLs，即它们应该和对应的节点上的<code>initial-advertise-peer-urls</code>的值对应。<br>如果为了测试的目的通过相同的配置分解多集群(或者创建和删除单个集群)，值得注意的是每一个集群应该给予独一无二的<code>initial-cluster-token</code>,通过做这些工作，即使它们具有相同的配置,etcd也可以为集群成员生成独一无二的集群Id和成员ID。这样可以在可能会扰乱集群的跨集群中交互中保护etcd。<br>etcd监听在<code>listen-client-urls</code>接受客户端流量，etcd将<code>advertise-client-urls</code>中指定的URLs告诉其他成员，代理，客户端。请确保潜在的客户端可以获取<code>advertise-client-urls</code>。一个常见的错误当远程的客户端应该访问etcd时设置<code>advertise-client-urls</code>为localhost或者将其保留为默认值。<br>在每一台机器上，通过这些参数启动etcd：</p><pre><code>$ etcd --name infra0 --initial-advertise-peer-urls http://10.0.1.10:2380 \  --listen-peer-urls http://10.0.1.10:2380 \  --listen-client-urls http://10.0.1.10:2379,http://127.0.0.1:2379 \  --advertise-client-urls http://10.0.1.10:2379 \  --initial-cluster-token etcd-cluster-1 \  --initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \  --initial-cluster-state new</code></pre><pre><code>$ etcd --name infra1 --initial-advertise-peer-urls http://10.0.1.11:2380 \  --listen-peer-urls http://10.0.1.11:2380 \  --listen-client-urls http://10.0.1.11:2379,http://127.0.0.1:2379 \  --advertise-client-urls http://10.0.1.11:2379 \  --initial-cluster-token etcd-cluster-1 \  --initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \  --initial-cluster-state new</code></pre><pre><code>$ etcd --name infra2 --initial-advertise-peer-urls http://10.0.1.12:2380 \  --listen-peer-urls http://10.0.1.12:2380 \  --listen-client-urls http://10.0.1.12:2379,http://127.0.0.1:2379 \  --advertise-client-urls http://10.0.1.12:2379 \  --initial-cluster-token etcd-cluster-1 \  --initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \  --initial-cluster-state new</code></pre><p>以<code>initial-cluster</code>开头的命令行参数将在etcd启动后被忽略。在初始化启动后可以自由删除环境变量或者命令行参数。如果配置信息在启动之后需要改变(例如在/从集群中添加或删除成员),看<a href="运行时重新配置.md">运行时配置</a>引导。</p><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><p>etcd支持通过TLS协议进行加密通信。TLS通道可以在集群内部通信使用，也可以在节点和客户端流量通信时使用。这一部分列举了为节点和客户端TLS通信的集群设置。添加的etcd的TLS支持信息细节可以在<strong>安全引导</strong>中发现。</p><h4 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h4><p>一个集群使用自签名证书加密流量和连接权限。使用自签名证书启动一个集群，每一个集群成员都需要含有一个独一无二的由共享的集群CA证书(<code>ca.crt</code>)签名的秘钥对(<code>member.crt</code>,<code>member.key</code>)，用于节点连接和客户端连接。证书可以通过下面的etcd<strong>TLS设置</strong>例子中生成。<br>对于每一台机器，etcd应该通过这些参数启动：</p><pre><code>$ etcd --name infra0 --initial-advertise-peer-urls https://10.0.1.10:2380 \  --listen-peer-urls https://10.0.1.10:2380 \  --listen-client-urls https://10.0.1.10:2379,https://127.0.0.1:2379 \  --advertise-client-urls https://10.0.1.10:2379 \  --initial-cluster-token etcd-cluster-1 \  --initial-cluster infra0=https://10.0.1.10:2380,infra1=https://10.0.1.11:2380,infra2=https://10.0.1.12:2380 \  --initial-cluster-state new \  --client-cert-auth --trusted-ca-file=/path/to/ca-client.crt \  --cert-file=/path/to/infra0-client.crt --key-file=/path/to/infra0-client.key \  --peer-client-cert-auth --peer-trusted-ca-file=ca-peer.crt \  --peer-cert-file=/path/to/infra0-peer.crt --peer-key-file=/path/to/infra0-peer.key</code></pre><pre><code>$ etcd --name infra1 --initial-advertise-peer-urls https://10.0.1.11:2380 \  --listen-peer-urls https://10.0.1.11:2380 \  --listen-client-urls https://10.0.1.11:2379,https://127.0.0.1:2379 \  --advertise-client-urls https://10.0.1.11:2379 \  --initial-cluster-token etcd-cluster-1 \  --initial-cluster infra0=https://10.0.1.10:2380,infra1=https://10.0.1.11:2380,infra2=https://10.0.1.12:2380 \  --initial-cluster-state new \  --client-cert-auth --trusted-ca-file=/path/to/ca-client.crt \  --cert-file=/path/to/infra1-client.crt --key-file=/path/to/infra1-client.key \  --peer-client-cert-auth --peer-trusted-ca-file=ca-peer.crt \  --peer-cert-file=/path/to/infra1-peer.crt --peer-key-file=/path/to/infra1-peer.key</code></pre><pre><code>$ etcd --name infra2 --initial-advertise-peer-urls https://10.0.1.12:2380 \  --listen-peer-urls https://10.0.1.12:2380 \  --listen-client-urls https://10.0.1.12:2379,https://127.0.0.1:2379 \  --advertise-client-urls https://10.0.1.12:2379 \  --initial-cluster-token etcd-cluster-1 \  --initial-cluster infra0=https://10.0.1.10:2380,infra1=https://10.0.1.11:2380,infra2=https://10.0.1.12:2380 \  --initial-cluster-state new \  --client-cert-auth --trusted-ca-file=/path/to/ca-client.crt \  --cert-file=/path/to/infra2-client.crt --key-file=/path/to/infra2-client.key \  --peer-client-cert-auth --peer-trusted-ca-file=ca-peer.crt \  --peer-cert-file=/path/to/infra2-peer.crt --peer-key-file=/path/to/infra2-peer.key</code></pre><h4 id="自动化证书"><a href="#自动化证书" class="headerlink" title="自动化证书"></a>自动化证书</h4><p>如果集群需要加密通信但是不需要连接时权限认证,etcd可以配置为自动生成秘钥.在初始化阶段,etcd成员基于他们的Ip地址和主机生成自己的秘钥.<br>在每一台主机上,etcd需要根据这些参数进行启动:</p><pre><code>$ etcd --name infra0 --initial-advertise-peer-urls https://10.0.1.10:2380 \  --listen-peer-urls https://10.0.1.10:2380 \  --listen-client-urls https://10.0.1.10:2379,https://127.0.0.1:2379 \  --advertise-client-urls https://10.0.1.10:2379 \  --initial-cluster-token etcd-cluster-1 \  --initial-cluster infra0=https://10.0.1.10:2380,infra1=https://10.0.1.11:2380,infra2=https://10.0.1.12:2380 \  --initial-cluster-state new \  --auto-tls \  --peer-auto-tls</code></pre><pre><code>$ etcd --name infra1 --initial-advertise-peer-urls https://10.0.1.11:2380 \  --listen-peer-urls https://10.0.1.11:2380 \  --listen-client-urls https://10.0.1.11:2379,https://127.0.0.1:2379 \  --advertise-client-urls https://10.0.1.11:2379 \  --initial-cluster-token etcd-cluster-1 \  --initial-cluster infra0=https://10.0.1.10:2380,infra1=https://10.0.1.11:2380,infra2=https://10.0.1.12:2380 \  --initial-cluster-state new \  --auto-tls \  --peer-auto-tls</code></pre><pre><code>$ etcd --name infra2 --initial-advertise-peer-urls https://10.0.1.12:2380 \  --listen-peer-urls https://10.0.1.12:2380 \  --listen-client-urls https://10.0.1.12:2379,https://127.0.0.1:2379 \  --advertise-client-urls https://10.0.1.12:2379 \  --initial-cluster-token etcd-cluster-1 \  --initial-cluster infra0=https://10.0.1.10:2380,infra1=https://10.0.1.11:2380,infra2=https://10.0.1.12:2380 \  --initial-cluster-state new \  --auto-tls \  --peer-auto-tls</code></pre><h4 id="错误案例"><a href="#错误案例" class="headerlink" title="错误案例"></a>错误案例</h4><p>在以下的例子中，新的主机没有包含在枚举的节点列表中，如果这是一个新的集群，节点需要被添加到初始化集群成员的列表中。</p><pre><code>$ etcd --name infra1 --initial-advertise-peer-urls http://10.0.1.11:2380 \  --listen-peer-urls https://10.0.1.11:2380 \  --listen-client-urls http://10.0.1.11:2379,http://127.0.0.1:2379 \  --advertise-client-urls http://10.0.1.11:2379 \  --initial-cluster infra0=http://10.0.1.10:2380 \  --initial-cluster-state newetcd: infra1 not listed in the initial cluster configexit 1</code></pre><p>在以下的例子中，我们试图映射一个节点(infra0)到一个不同的地址(127.0.0.1:2380)，而它在集群列表中的地址为(10.0.1.10:2380).如果这个节点监听多个端口，所有地址都必须要反射到<code>initial-cluster</code>参数配置中。</p><pre><code>$ etcd --name infra0 --initial-advertise-peer-urls http://127.0.0.1:2380 \  --listen-peer-urls http://10.0.1.10:2380 \  --listen-client-urls http://10.0.1.10:2379,http://127.0.0.1:2379 \  --advertise-client-urls http://10.0.1.10:2379 \  --initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \  --initial-cluster-state=newetcd: error setting up initial cluster: infra0 has different advertised URLs in the cluster and advertised peer URLs listexit 1</code></pre><p>如果一个节点被配置成不同集群的参数并试图加入这个集群，etcd将会报出集群ID不匹配并退出.</p><pre><code>$ etcd --name infra3 --initial-advertise-peer-urls http://10.0.1.13:2380 \  --listen-peer-urls http://10.0.1.13:2380 \  --listen-client-urls http://10.0.1.13:2379,http://127.0.0.1:2379 \  --advertise-client-urls http://10.0.1.13:2379 \  --initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra3=http://10.0.1.13:2380 \  --initial-cluster-state=newetcd: conflicting cluster ID to the target cluster (c6ab534d07e8fcc4 != bc25ea2a74fb18b0). Exiting.exit 1</code></pre><h3 id="发现服务"><a href="#发现服务" class="headerlink" title="发现服务"></a>发现服务</h3><p>在许多案例中，集群节点不能提前知道Ip地址。这在云服务提供商或者是使用DHCP的网络中很常见。在这种情况下，使用一个存在的etcd集群来启动一个新的节点而不是进行静态的配置，这个过程称为”节点发现”.</p><p>有两种方法可以用来发现节点:</p><ul><li>etcd发现服务</li><li>DNS SRV 记录</li></ul><h4 id="etcd-发现服务"><a href="#etcd-发现服务" class="headerlink" title="etcd 发现服务"></a>etcd 发现服务</h4><p>为了更好理解发现服务协议的设计，我们建议阅读发现服务协议<strong>文档</strong>.<br>** <strong>发现服务URL的生命周期</strong> **<br>一个发现URL标识一个独有的etcd集群而不是使用已有的发现URL。每一个etcd实例分享一个新的发现URL去启动新的集群。<br>此外，发现URL应该只在初始化启动集群的时候使用，如果需要改变已经启动的集群中的成员关系，看<a href="运行时重新配置.md">运行时重新配置</a>引导.<br>** <strong>自定义etcd发现服务</strong> **<br>发现服务用于启动一个存在的集群，如果使用一个私有的etcd集群，像这样创建URL:</p><pre><code>$ curl -X PUT https://myetcd.local/v2/keys/discovery/6c007a14875d53d9bf0ef5a6fc0257c817f0fb83/_config/size -d value=3</code></pre><p>通过设置URL中Key的大小，创建发现URL的集群预期大小为3.<br>在这种情况下URL将会这样使用:</p><pre><code>https://myetcd.local/v2/keys/discovery/6c007a14875d53d9bf0ef5a6fc0257c817f0fb83</code></pre><p>当etcd成员启动时将使用</p><pre><code>https://myetcd.local/v2/keys/discovery/6c007a14875d53d9bf0ef5a6fc0257c817f0fb83</code></pre><p>文件夹进行注册。<br><strong>每一个成员必须含有一个不同的命名参数。<code>Hostname</code>或者<code>machine-id</code>将是一个好的选择。发现服务的失败通常由于重复的名字。</strong><br>现在我们通过这些参数启动etcd的每一个成员：</p><pre><code>$ etcd --name infra0 --initial-advertise-peer-urls http://10.0.1.10:2380 \  --listen-peer-urls http://10.0.1.10:2380 \  --listen-client-urls http://10.0.1.10:2379,http://127.0.0.1:2379 \  --advertise-client-urls http://10.0.1.10:2379 \  --discovery https://myetcd.local/v2/keys/discovery/6c007a14875d53d9bf0ef5a6fc0257c817f0fb83</code></pre><pre><code>$ etcd --name infra1 --initial-advertise-peer-urls http://10.0.1.11:2380 \  --listen-peer-urls http://10.0.1.11:2380 \  --listen-client-urls http://10.0.1.11:2379,http://127.0.0.1:2379 \  --advertise-client-urls http://10.0.1.11:2379 \  --discovery https://myetcd.local/v2/keys/discovery/6c007a14875d53d9bf0ef5a6fc0257c817f0fb83</code></pre><pre><code>$ etcd --name infra2 --initial-advertise-peer-urls http://10.0.1.12:2380 \  --listen-peer-urls http://10.0.1.12:2380 \  --listen-client-urls http://10.0.1.12:2379,http://127.0.0.1:2379 \  --advertise-client-urls http://10.0.1.12:2379 \  --discovery https://myetcd.local/v2/keys/discovery/6c007a14875d53d9bf0ef5a6fc0257c817f0fb83</code></pre><p>一旦所有主机被注册后，每一个集群成员将会集群启动之前在自定义发现服务中注册自己。<br>** <strong>公共的etcd发现服务</strong> **<br>如果没有可以获得的集群，使用托管在<code>discovery.etcd.io</code>的公共发现服务。通过”new”主机,创建一个私有的发现URL,使用以下命令:</p><pre><code>$ curl https://discovery.etcd.io/new?size=3https://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573de</code></pre><p>将会创建一个初始化成员数量为3的集群,如果没有设置大小，将默认为3.</p><pre><code>ETCD_DISCOVERY=https://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573de</code></pre><pre><code>--discovery https://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573de</code></pre><p>现在我们通过这些相关的参数启动每一个etcd成员：</p><pre><code>$ etcd --name infra0 --initial-advertise-peer-urls http://10.0.1.10:2380 \  --listen-peer-urls http://10.0.1.10:2380 \  --listen-client-urls http://10.0.1.10:2379,http://127.0.0.1:2379 \  --advertise-client-urls http://10.0.1.10:2379 \  --discovery https://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573de</code></pre><pre><code>$ etcd --name infra1 --initial-advertise-peer-urls http://10.0.1.11:2380 \  --listen-peer-urls http://10.0.1.11:2380 \  --listen-client-urls http://10.0.1.11:2379,http://127.0.0.1:2379 \  --advertise-client-urls http://10.0.1.11:2379 \  --discovery https://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573de</code></pre><pre><code>$ etcd --name infra2 --initial-advertise-peer-urls http://10.0.1.12:2380 \  --listen-peer-urls http://10.0.1.12:2380 \  --listen-client-urls http://10.0.1.12:2379,http://127.0.0.1:2379 \  --advertise-client-urls http://10.0.1.12:2379 \  --discovery https://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573de</code></pre><p>一旦所有主机被注册后，每一个集群成员将会集群启动之前在自定义发现服务中注册自己。<br>etcd使用环境变量<code>ETCD_DISCOVERY_PROXY</code>通过HTTP代理连接发现服务。<br>** <strong>错误和警告案例</strong> **<br>发现服务错误：</p><pre><code>$ etcd --name infra0 --initial-advertise-peer-urls http://10.0.1.10:2380 \  --listen-peer-urls http://10.0.1.10:2380 \  --listen-client-urls http://10.0.1.10:2379,http://127.0.0.1:2379 \  --advertise-client-urls http://10.0.1.10:2379 \  --discovery https://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573deetcd: error: the cluster doesn’t have a size configuration value in https://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573de/_configexit 1</code></pre><p>警告<br>这里有一个严重的警告表明发现服务URL将被这台主机忽略。</p><pre><code>$ etcd --name infra0 --initial-advertise-peer-urls http://10.0.1.10:2380 \  --listen-peer-urls http://10.0.1.10:2380 \  --listen-client-urls http://10.0.1.10:2379,http://127.0.0.1:2379 \  --advertise-client-urls http://10.0.1.10:2379 \  --discovery https://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573deetcdserver: discovery token ignored since a cluster has already been initialized. Valid log found at /var/lib/etcd</code></pre><h3 id="DNS-发现服务"><a href="#DNS-发现服务" class="headerlink" title="DNS 发现服务"></a>DNS 发现服务</h3>]]></content>
    
    
    
    <tags>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单机集群</title>
    <link href="undefined2019/11/23/blog/etcd/%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4/"/>
    <url>2019/11/23/blog/etcd/%E5%8D%95%E6%9C%BA%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="设置单节点集群"><a href="#设置单节点集群" class="headerlink" title="设置单节点集群"></a>设置单节点集群</h2><p>对于测试环境与开发环境，最快速与简单的方式是配置一个本地集群。对于生产环境，参考<strong>集群</strong>部分。</p><h3 id="本地单节点集群"><a href="#本地单节点集群" class="headerlink" title="本地单节点集群"></a>本地单节点集群</h3><h5 id="启动一个集群"><a href="#启动一个集群" class="headerlink" title="启动一个集群"></a>启动一个集群</h5><p>运行以下命令来部署一个单节点的etcd集群:</p><pre><code>$ ./etcd...</code></pre><p>如果<code>etcd</code>二进制文件不在当前工作目录，那可能位于<code>$GOPATH/bin/etcd</code>或者是<code>/usr/local/bin/etcd</code>.合适地运行命令。<br>运行的<code>etcd</code>成员在<code>localhost:2379</code>监听客户端的请求。</p><h5 id="与集群进行交互"><a href="#与集群进行交互" class="headerlink" title="与集群进行交互"></a>与集群进行交互</h5><p>使用<code>etcdctl</code>与运行中的集群进行交互操作<br>    1.     例子：在集群中存储一个键值对：</p><pre><code>$ ./etcdctl put foo barOK</code></pre><p>如果<code>OK</code>被打印在控制台，说明已经成功存储Key-Value对。<br>    2.     获取键<code>foo</code>对应的值：</p><pre><code>$ ./etcdctl get foobar</code></pre><p>如果<code>bar</code>被返回，说明与<code>etcd</code>集群的交互操作和期望中的相同。</p><h3 id="本地多节点集群"><a href="#本地多节点集群" class="headerlink" title="本地多节点集群"></a>本地多节点集群</h3><h5 id="启动一个集群-1"><a href="#启动一个集群-1" class="headerlink" title="启动一个集群"></a>启动一个集群</h5><p>在<code>etcd</code>的<code>git</code>仓库中存在一个<code>Procfile</code>文件提供一种简单的方式可以对本地多节点集群进行配置。在启动多节点集群之前，将工作目录导向<code>etcd</code>的根目录并执行以下操作：</p><pre><code>1.    安装`goreman`控制基于`Procfile`的应用：```$ go get github.com/mattn/goreman```2.    使用 `etcd`的配置文件`Procfile`通过`goreman`启动一个集群：```$ goreman -f Procfile start```集群成员已经启动了，并在`localhost:2379`,localhost:22379`,localhost:32379`监听客户端的请求。</code></pre><h5 id="与集群进行交互-1"><a href="#与集群进行交互-1" class="headerlink" title="与集群进行交互"></a>与集群进行交互</h5><p>使用<code>etcdctl</code>与运行中的集群进行交互操作:</p><pre><code>1. 打印成员列表：$ `etcdctl --write-out=table --endpoints=localhost:2379 member list``etcd`集群中的成员列表显示如下：</code></pre><table><thead><tr><th align="left">ID</th><th align="left">STATUS</th><th align="left">NAME</th><th align="left">PEER ADDRS</th><th align="left">CLIENT ADDRS</th></tr></thead><tbody><tr><td align="left">8211f1d0f64f3269</td><td align="left">started</td><td align="left">infra1</td><td align="left"><a href="http://127.0.0.1:2380" target="_blank" rel="noopener">http://127.0.0.1:2380</a></td><td align="left"><a href="http://127.0.0.1:2379" target="_blank" rel="noopener">http://127.0.0.1:2379</a></td></tr><tr><td align="left">91bc3c398fb3c146</td><td align="left">started</td><td align="left">infra1</td><td align="left"><a href="http://127.0.0.1:22380" target="_blank" rel="noopener">http://127.0.0.1:22380</a></td><td align="left"><a href="http://127.0.0.1:22379" target="_blank" rel="noopener">http://127.0.0.1:22379</a></td></tr><tr><td align="left">fd422379fda50e48</td><td align="left">started</td><td align="left">infra1</td><td align="left"><a href="http://127.0.0.1:32380" target="_blank" rel="noopener">http://127.0.0.1:32380</a></td><td align="left"><a href="http://127.0.0.1:32379" target="_blank" rel="noopener">http://127.0.0.1:32379</a></td></tr></tbody></table><pre><code>2.     例子：在集群中存储一个Key-Value对：</code></pre><pre><code>$ ./etcdctl put foo barOK</code></pre><p>如果<code>OK</code>被打印在控制台，说明已经成功存储键-值对。</p><h5 id="容错测试"><a href="#容错测试" class="headerlink" title="容错测试"></a>容错测试</h5><p>关闭一个成员然后尝试通过键获取值来进行容错测试：</p><ol><li>获取一个运行中的成员的名字然后停止它：<br> <code>Procfile</code>列出了多节点集群的属性信息。例如，名称为<code>etcd2</code>的运行中的成员。</li><li>停止该成员：<pre><code>#kill etcd2$ goreman run stop etcd2</code></pre></li><li>存储一个键：<pre><code>$ etcdctl put key helloOK</code></pre></li><li>获取前一步所存储的键： <pre><code>$ etcdctl get keyhello</code></pre></li><li>从已经停止的成员处获取键：<pre><code>$ etcdctl --endpoints=localhost:22379 get key</code></pre>该命令应该由于连接失败展示一个错误：<pre><code>2017/06/18 23:07:35 grpc: Conn.resetTransport failed to create client transport: connection error: desc = &quot;transport: dial tcp 127.0.0.1:22379: getsockopt: connection refused&quot;; Reconnecting to &quot;localhost:22379&quot;Error:  grpc: timed out trying to connect</code></pre></li><li>重启停止的成员：<pre><code>$ goreman run restart etcd2</code></pre></li><li>从重启的成员处获取键：<pre><code>$ etcdctl --endpoints=localhost:22379 get keyhello</code></pre>重启的成员重新建立了连接.<code>etcdctl</code>将能够成功地从重启的成员处接受键,读<a href="与etcd进行交互.md">与etcd进行交互</a>部分学习更多关于与etcd交互的内容。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>etcd文档</title>
    <link href="undefined2019/11/23/blog/etcd/%E6%96%87%E6%A1%A3/"/>
    <url>2019/11/23/blog/etcd/%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><hr><p>etcd是一个分布式键值对存储，被设计为可靠的，快速的保存并提供对关键数据的访问。通过分布式锁，领导选举和写屏障使能分布式一致性。一个etcd集群旨在实现高可用和持久性数据存储与检索。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><hr><h3 id="使用etcd进行开发"><a href="#使用etcd进行开发" class="headerlink" title="使用etcd进行开发"></a>使用etcd进行开发</h3><hr><p>一种简单的方式<a href="单机集群.md">设置本地集群</a>开始使用etcd作为分布式键值对存储</p><ul><li><a href="单机集群.md">设置本地集群</a></li><li><a href="与etcd进行交互.md">与etcd进行交互</a></li><li><a href="">gRPC etcd核心</a>和<a href="">etcd 并发</a>API参考</li><li><a href="HTTP_JSON_API通过gRPC网关.md">HTTP JSON API 通过gRPC网关</a></li><li><a href="gRPC命名与发现.md">gRPC命名和发现</a></li><li><a href="">客户端</a>和<a href="">代理</a>命名空间</li><li><a href="">嵌入式etcd</a></li><li><a href="">实验特性和APIs</a></li><li><a href="">系统限制</a></li></ul><h3 id="操作etcd集群"><a href="#操作etcd集群" class="headerlink" title="操作etcd集群"></a>操作etcd集群</h3><hr><p>对开发或者生产环境，管理员需要一个错误容忍etcd集群，从<a href="多机集群.md">多机集群</a>开始。</p><h4 id="设置etcd"><a href="#设置etcd" class="headerlink" title="设置etcd"></a>设置etcd</h4><ul><li><a href="">配置标记</a></li><li><a href="">多成员集群</a></li><li><a href="">gRPC代理</a></li><li><a href="">L4网关</a></li></ul><h4 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h4><ul><li><a href="">支持的系统</a></li><li><a href="">硬件配置建议</a></li><li><a href="">性能基准测试</a></li><li><a href="">调节</a></li></ul><h4 id="平台引导"><a href="#平台引导" class="headerlink" title="平台引导"></a>平台引导</h4><ul><li><a href="">亚马逊Web服务</a></li><li><a href="">Linux容器，systemd</a></li><li><a href="">RessBSD</a></li><li><a href="">Docker容器</a></li><li><a href="">rkt容器</a></li></ul><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><ul><li><a href="">TLS</a></li><li><a href="">基于角色的访问控制</a></li></ul><h4 id="维护和故障排除"><a href="#维护和故障排除" class="headerlink" title="维护和故障排除"></a>维护和故障排除</h4><ul><li><a href="">常见问题</a></li><li><a href="">监控方式</a></li><li><a href="">维护</a></li><li><a href="">失败模式</a></li><li><a href="">容灾恢复</a></li><li><a href="">更新</a><h4 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h4>要了解有关etcd的概念和内部知识的更多信息，请阅读以下页面：</li><li><a href="">什么是etcd</a></li><li><a href="">理解数据模式</a></li><li><a href="">理解APIs</a></li><li><a href="">词汇表</a></li><li>设计<ul><li><a href="">权限子系统</a></li><li><a href="">客户端</a></li><li><a href="">学习者</a></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>etcd</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>