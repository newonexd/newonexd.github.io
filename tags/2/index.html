<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon.jpg">
  <link rel="icon" type="image/png" href="/img/icon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content="学习区块链技术ing...">
  <meta name="author" content="任晓东">
  <meta name="keywords" content="blockchain fabric">
  <title>触不可及的官方网站</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.10.2/css/all.min.css"  >
<link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css"  >
<link rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.8.9/css/mdb.min.css"  >
<link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css"  >

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/css/main.css"  >


  <link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"  >


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 100vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>触不可及的官方网站</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">主页</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>


</nav>

    <div class="view intro-2" id="background"
         style="background: url('/img/0.jpg')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="fas fa-angle-down scroll-down-arrow"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      <div class="container nopadding-md">
        <div class="py-5 z-depth-3" id="board">
          
          <div class="container">
            <div class="row">
              <div class="col-12 col-md-10 m-auto">
                


  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/01/05/blog/consensus/raft-log/">
        <p class="h4 index-header">Raft算法之日志复制</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">上一篇文章:Raft算法之Leader选举&emsp;&emsp;之前说完了Raft算法中的Leader选举过程，本文将在上一篇文章的基础上说明日志复制。
Raft算法之日志复制&emsp;&emsp;先看以下日志所包含的基本内容:

可以被复制状态机执行的命令
任期号 :创建该日志时Leader所处的当前任期号
索引号 :整数，用于标识日志所在的位置

日志的状态分为两种:未被提交，已被提交(日志为安全的，不会被删除或覆盖)。
1 正常情况
当Leader接收到由客户端发送的请求(请求中包含可以被复制状态机执行的命令)时，Leader将会把该请求作为新的内容添加到日志中(任期号为当前Leader所处的任期号，索引号为当前Leader本地存储的日志集合中的日志的最高索引号加1)。
Leader在当前任期内最多只能创建一个给定索引号的日志(即不可能在一个任期内创建两个以上的具有相同索引的日志条目)


然后将该日志通过AppendEntries RPC消息发送到网络中其他的服务器(以下简称Follower)，从而复制该日志。
在网络中Follower接收到该日志消息后则会返回复制成功的回</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-01-05&nbsp;&nbsp;
        
        
          <i class="iconfont icon-inbox"></i>
          
            <a href="/categories/algorithm">algorithm</a>&nbsp;
          &nbsp;
        
        
          <i class="iconfont icon-tag"></i>
          
            <a href="/tags/algorithm">algorithm</a>&nbsp;
          
            <a href="/tags/Raft">Raft</a>&nbsp;
          
        
            
                
                &nbsp;<i class="far fa-chart-bar"></i>
                <span class="post-count">
                    3.5k 字
                  </span>&nbsp;
            
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/01/04/blog/consensus/raft-election/">
        <p class="h4 index-header">Raft算法之Leader选举</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">&emsp;&emsp;记录一下对Raft算法的理解，算法的内容比较多，所以准备将算法的全部过程分成四个部分来写。分别是

Raft算法之Leader选举
Raft算法之日志复制
Raft算法之成员关系变化
Raft算法之日志压缩

该文章为第一部分。
Raft算法之Leader选举简单介绍&emsp;&emsp;首先需要了解Raft中的一个关键词:Term,本文中以下部分简单称为任期。任期通过连续的整数编号表示并且是单调递增的，代表任意长度的一段时间。在网络中所有服务器都有自己的任期编号，在网络中大部分正常运行阶段，所有服务器的任期号都是相同的。Raft算法中服务器主要分为三种角色:Leader,Follower,Candidate，并且三种角色相互独立，也就是服务器在同一时间内只可能扮演其中一种角色。

Leader:用于对所有用户的请求进行处理。以及之后要说明的日志的复制等等。
Follower:不会主动发送消息，只响应来自Leader与Candidate的请求。
Candidate:用于选举新的Leader。

&emsp;&emsp;在本文介绍的范围内，网络状态分为两种情况:</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-01-04&nbsp;&nbsp;
        
        
          <i class="iconfont icon-inbox"></i>
          
            <a href="/categories/algorithm">algorithm</a>&nbsp;
          &nbsp;
        
        
          <i class="iconfont icon-tag"></i>
          
            <a href="/tags/algorithm">algorithm</a>&nbsp;
          
            <a href="/tags/Raft">Raft</a>&nbsp;
          
        
            
                
                &nbsp;<i class="far fa-chart-bar"></i>
                <span class="post-count">
                    1.9k 字
                  </span>&nbsp;
            
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/01/04/blog/consensus/raft/">
        <p class="h4 index-header">Raft算法论文(部分)</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">原文地址-&gt;Raft算法
摘要Raft是用于管理被复制的日志的共识算法。它与multi-Paxos算法产生的效果相同，并且和Paxos算法一样高效。但是结构与Paxos不同。这使得Raft算法比Paxos算法更容易理解。也为构建实际系统提供了更好的基础。为了加强理解，Raft将几个关键元素分离，比如leader选举，日志复制，安全性。并增强了一致性，以减少必须考虑的状态数。一项用户研究的结果表明，与Paxos相比，Raft算法更易于学生学习。Raft也提供了用于更新集群成员关系的新的机制。它使用重叠的多数来保证安全。
1 介绍共识算法允许一组计算机的集合作为一个一致的的小组工作，这些小组可以承受某些成员的故障。正因为如此，共识机制在构建可信的大规模软件系统中起着至关重要的作用。在过去的十年中，Paxos一直主导着共识算法的讨论。很多共识算法都是基于Paxos或者受它的影响。Paxos称为了教受学生关于共识算法的主要工具。不幸的是，尽管进行了许多尝试以使Paxos更加平易近人，Paxos仍然非常难以理解。此外，其体系结构需要复杂的更改以支持实际系统。结果，系统构建者和学生都与Pax</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-01-04&nbsp;&nbsp;
        
        
          <i class="iconfont icon-inbox"></i>
          
            <a href="/categories/algorithm">algorithm</a>&nbsp;
          &nbsp;
        
        
          <i class="iconfont icon-tag"></i>
          
            <a href="/tags/algorithm">algorithm</a>&nbsp;
          
            <a href="/tags/Raft">Raft</a>&nbsp;
          
        
            
                
                &nbsp;<i class="far fa-chart-bar"></i>
                <span class="post-count">
                    15k 字
                  </span>&nbsp;
            
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/12/31/blog/fabric/%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AERaft%E8%8A%82%E7%82%B9/">
        <p class="h4 index-header">Hyperledger Fabric动态配置Raft节点</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Hyperledger Fabric动态配置Raft节点最近看官方文档发现新的共识算法etcdRaft允许动态添加或删除排序节点，所以也花了一天时间操作了以下，写篇文章把整个过程记录一下。初始网络本文设置了4个Orderer节点，1个Peer节点(用于更新配置文件以及测试用),然后动态添加第五个Orderer节点。本文分成两个部分:

第一部分是手动通过Fabric-CA生成每一个节点的证书文件
第二部分是更新Fabric网络配置添加新的Orderer节点。

本文基于Fabric v2.0.0-beta版本。版本号只要高于1.4.1就行
1 搭建定制化的Fabric网络前提条件是成功跑起来Fabric的示例网络，可以看这里-&gt;Hyperledger Fabric环境搭建
首先在$GOPATH下(本文路径地址为$GOPATH/src/github.com/hyperledger/fab)建立如下几个文件夹用于之后的操作:
.  # 这里是根目录fab
├── ca    # 用于生成CA证书的ca配置文件的文件夹
│   ├── org1
│   │   └── fabric-c</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2019-12-31&nbsp;&nbsp;
        
        
          <i class="iconfont icon-inbox"></i>
          
            <a href="/categories/fabric%E5%BA%94%E7%94%A8">fabric应用</a>&nbsp;
          &nbsp;
        
        
          <i class="iconfont icon-tag"></i>
          
            <a href="/tags/fabric">fabric</a>&nbsp;
          
        
            
                
                &nbsp;<i class="far fa-chart-bar"></i>
                <span class="post-count">
                    7.2k 字
                  </span>&nbsp;
            
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/12/28/blog/fabric/TLS_SDK%E8%B0%83%E7%94%A8/">
        <p class="h4 index-header">Hyperledger Fabric 开启TLS调用Java SDK</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Hyperledger Fabric 开启TLS调用Java SDK之前更新的Fabric 1.4.1+版本之后新增了etcdRaft共识机制，而且官方文档明确指定了如果使用该共识机制就必须开启TLS，所以之前通过关闭TLS调用SDK的方式就不好用了，并且Fabric 2.0版本抛弃了solo，kafka模式，也就是默认都使用etcdRaft共识了，所以记录一下如何开开启TLS的情况下使用SDK.
在之前，本文是直接使用了Fabric v2.0.0-beta版本的环境，并且JAVA SDK版本也是直接用了v2.0.0的版本，所以如果Fabric以及SDK不会在正式版的2.0.0版本发生重大更新的话，本文的方案应该是可以满足v2.0.0+版本的使用的。
先说一下运行环境：

Hyperledger Fabric v2.0.0-beta
Hyperledger Fabric-sdk-java v2.0.0-SNAPSHOT
Java 1.8

本文分成两个部分:

Hyperledger Fabric v2.0.0-beta版本的安装
Hyperledger Fabric-sdk-java</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2019-12-28&nbsp;&nbsp;
        
        
          <i class="iconfont icon-inbox"></i>
          
            <a href="/categories/fabric%E5%BA%94%E7%94%A8">fabric应用</a>&nbsp;
          &nbsp;
        
        
          <i class="iconfont icon-tag"></i>
          
            <a href="/tags/fabric">fabric</a>&nbsp;
          
        
            
                
                &nbsp;<i class="far fa-chart-bar"></i>
                <span class="post-count">
                    3.3k 字
                  </span>&nbsp;
            
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/12/27/blog/fabric/%E9%93%BE%E7%A0%81%E4%BD%9C%E4%B8%BA%E5%A4%96%E9%83%A8%E6%9C%8D%E5%8A%A1/">
        <p class="h4 index-header">Hyperledger Fabric链码作为外部服务</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">链码作为外部服务Fabric v2.0支持链码在Fabric环境外部署和执行。允许用户管理与节点保持独立的链码运行。这种方案激励了Fabric中的链码云部署，例如Kubernetes。代替了在每一个节点上面构建与运行链码。链码可以作为一个服务运行，它的生命周期将可以在Fabric环境外进行管理。这种措施利用Fabirc v2.0的外部构建和运行功能。其功能具有允许操作者通过程序构建，运行，发现链码对节点进行扩展。在读取本文内容之前，应该对外部构建与扩展较为熟悉。
在外部构建功能可以使用之前，链码包内容要求指定的编程语言的源代码进行构建并作为链码二进制文件运行。新的外部构建和运行功能允许用户有选择地定制化构建过程。将链码作为外部服务运行。构建过程允许指定链码运行服务的端点信息。因此包内容可以简单地由外部链码运行服务端点信息和用于安全通信的TLS归档组成。TLS是可选的，但是除了简单的测试环境以外，强烈建议所有环境都使用TLS。
接下来的部分将描述如何将链码配置为外部服务：

打包链码
配置节点对外部链码进行处理
外部构建和运行的简单脚本文件
编写链码作为外部服务运行
部署链码
将链码作为</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2019-12-27&nbsp;&nbsp;
        
        
          <i class="iconfont icon-inbox"></i>
          
            <a href="/categories/fabric%E5%BA%94%E7%94%A8">fabric应用</a>&nbsp;
          &nbsp;
        
        
          <i class="iconfont icon-tag"></i>
          
            <a href="/tags/fabric">fabric</a>&nbsp;
          
        
            
                
                &nbsp;<i class="far fa-chart-bar"></i>
                <span class="post-count">
                    2.4k 字
                  </span>&nbsp;
            
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/12/26/blog/couchDB/CouchDB%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">
        <p class="h4 index-header">CouchDB基本操作</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">CouchDB操作判断数据库是否正常运行:
curl http://localhost:5984/_up | jq .获取CouchDB唯一标识符(UUID):
curl http://localhost:5984/_uuids | jq .获取CouchDB数据库信息:
curl http://localhost:5984/ | jq .节点操作查询节点查询所有节点查询当前节点连接的所有节点以及集群中的节点：
curl -u admin:admin http://localhost:5984/_membership查询单个节点状态curl -u admin:admin http://localhost:5984/_node/{node-name}/_stats
# 查询本地节点状态
curl -u admin:admin http://localhost:5984/_node/local/_stats 数据库操作查询数据库查询所有数据库:
curl http://localhost:5984/_all_dbs | jq .查询某个数据库详细信息:
curl http://localh</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2019-12-26&nbsp;&nbsp;
        
        
          <i class="iconfont icon-inbox"></i>
          
            <a href="/categories/CouchDb%E5%BA%94%E7%94%A8">CouchDb应用</a>&nbsp;
          &nbsp;
        
        
          <i class="iconfont icon-tag"></i>
          
            <a href="/tags/CouchDb">CouchDb</a>&nbsp;
          
        
            
                
                &nbsp;<i class="far fa-chart-bar"></i>
                <span class="post-count">
                    920 字
                  </span>&nbsp;
            
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/12/24/blog/fabric/%E5%A4%96%E9%83%A8%E9%93%BE%E7%A0%81%E6%9E%84%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C/">
        <p class="h4 index-header">Hyperledger Fabric外部链码构建与运行</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">外部链码构建与运行
官方文档在Hyperledger Fabric 2.0版本之前，链码的构建和运行是节点实现的一部分，并且定制化是困难的。所有链码在节点上实例化是通过”构建“即根据语言指定的逻辑在节点上硬编码。构建过程将生成Docker容器镜像作为客户端连接节点用来运行可执行的链码。这种方法将链代码实现限制为只能使用几种语言实现，要求Docker成为部署环境的一部分，并阻止将链代码作为长时间运行的服务器进程运行。
外部构建模式Hyperledger Fabric外部构建器和启动器大致基于Heroku Buildpacks。buildpack实现只是将程序归档转换为可以运行的程序或脚本的集合。buildpack模型已针对链码包进行了调整，并扩展为支持链码执行和发现。
外部构建和运行API外部构建和运行由4个脚本程序组成：

bin/detect:确定是否应使用此buildpack来构建chaincode程序包并启动它
bin/build:转换链码包为可执行的链码
bin/release(可选):为peer节点提供关于链码的元数据
bin/run(可选):运行链码

bin/detect</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2019-12-24&nbsp;&nbsp;
        
        
          <i class="iconfont icon-inbox"></i>
          
            <a href="/categories/fabric%E5%BA%94%E7%94%A8">fabric应用</a>&nbsp;
          &nbsp;
        
        
          <i class="iconfont icon-tag"></i>
          
            <a href="/tags/fabric">fabric</a>&nbsp;
          
        
            
                
                &nbsp;<i class="far fa-chart-bar"></i>
                <span class="post-count">
                    2.5k 字
                  </span>&nbsp;
            
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/12/24/blog/fabric/%E4%BD%BF%E7%94%A8%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9D%97/">
        <p class="h4 index-header">Hyperledger Fabric使用硬件安全模块(HSM)</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">使用硬件安全模块官方文档可以通过Fabric节点使用硬件安全模块(HSM)来产生和存储私钥。HSM用于保护私钥和处理加密操作。允许peer节点与orderer节点在不暴露他们的私钥的条件下去签名和背书交易，当前Fabric只支持使用PKCS11标准与HSM进行通信。
配置HSM为了在Fabric节点上使用HSM，需要更新关于节点配置文件如core.yaml中的BCCSP(加密服务提供者)部分.在BCCSP部分，需要选择PKCS11作为提供者并提供需要使用的PKCS11库的路径。还需要提供为加密操作创建的令牌的标签和密码。可以使用令牌去生成和存储多个秘钥。预先构建的Hyperledger Fabric Docker镜像不能够使用PKCS11。如果使用Docker部署Fabric，需要通过以下的命令启动PKCS11构建自己的镜像。
make docker GO_TAGS=pkcs11同时也需要确保PKCS11的库文件是有效的，挂载到容器内部或者通过节点安装后是可以使用的。
示例接下来的示例说明了如何去配置一个可以使用HSM的Fabirc节点。
首先，需要安装一个实现了PKCS11的接口。本</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2019-12-24&nbsp;&nbsp;
        
        
          <i class="iconfont icon-inbox"></i>
          
            <a href="/categories/fabric%E5%BA%94%E7%94%A8">fabric应用</a>&nbsp;
          &nbsp;
        
        
          <i class="iconfont icon-tag"></i>
          
            <a href="/tags/fabric">fabric</a>&nbsp;
          
        
            
                
                &nbsp;<i class="far fa-chart-bar"></i>
                <span class="post-count">
                    1.3k 字
                  </span>&nbsp;
            
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2019/12/24/blog/couchDB/CouchDB%E5%AD%A6%E4%B9%A0-API/">
        <p class="h4 index-header">CouchDB学习-API</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">APIAPI URL路径可以指定访问CouchDB服务器的某个组件。URL请求结果包括标识和访问的数据库中的高效的描述字段。与所有URL一样，各个组件之间用正斜杠分隔。通常，以_（下划线）字符开头的URL组件和JSON字段表示服务器或返回的对象中的特殊组件或实体。例如，URL片段/_all_dbs获取CouchDB实例中所有数据库的列表。该引用根据URL结构进行构造，如下所示。
1 基本APICouchDB API是与CouchDB实例接口的主要方法。使用HTTP发出请求，请求用于从数据库请求信息，存储新数据以及对文档中存储的信息进行查看和格式化。对API的请求可以按您正在访问的CouchDB系统的不同区域以及用于发送请求的HTTP方法进行分类。不同的方法意味着不同的操作，例如，从数据库中检索信息通常由GET操作处理，而更新则由POST或PUT请求处理。不同方法必须提供的信息之间存在一些差异。有关基本HTTP方法和请求结构的指南，请参见请求格式和响应。对于几乎所有操作，都在JavaScript对象表示法（JSON）对象中定义了提交的数据和返回的数据结构。 JSON基础知识中提供了有关J</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2019-12-24&nbsp;&nbsp;
        
        
          <i class="iconfont icon-inbox"></i>
          
            <a href="/categories/CouchDb%E5%AD%A6%E4%B9%A0">CouchDb学习</a>&nbsp;
          &nbsp;
        
        
          <i class="iconfont icon-tag"></i>
          
            <a href="/tags/CouchDb">CouchDb</a>&nbsp;
          
        
            
                
                &nbsp;<i class="far fa-chart-bar"></i>
                <span class="post-count">
                    5.4k 字
                  </span>&nbsp;
            
      </div>
    </div>
  </div>



  <nav aria-label="index posts navigation">
    <span class="pagination pg-blue justify-content-center mt-5" id="pagination">
      <a class="extend prev" rel="prev" href="/"><i class="fas fa-angle-double-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/tags/3/">3</a><a class="page-number" href="/tags/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/tags/7/">7</a><a class="extend next" rel="next" href="/tags/3/"><i class="fas fa-angle-double-right"></i></a>
    </span>
  </nav>
  
  <script>
    for (ele of document.getElementById("pagination").getElementsByClassName("page-number")) {
      ele.href += '#board';
    }
  </script>



              </div>
            </div>
          </div>
        </div>
      </div>
    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv">总访问量 
          <span id="busuanzi_value_site_pv"></span> 次</span>&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv">总访客数 
            <span id="busuanzi_value_site_uv"></span> 人</span>&nbsp;
  
  全站共 <span class="post-count">152.5k</span> 字
  <br>



    


    <!-- 在网页底部添加网站运行时间 -->
    <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
    <script>
      var now = new Date();
      function createtime() {
        var grt= new Date("11/23/2019 12:31:24");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "网站运行时长共计:"+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
      }
      setInterval("createtime()",250);
    </script>
  </div>
</footer>

<!-- SCRIPTS -->
<script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script src="https://cdn.staticfile.org/popper.js/1.15.0/umd/popper.min.js" ></script>
<script src="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js" ></script>
<script src="https://cdn.staticfile.org/mdbootstrap/4.8.9/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>





  <script src="https://cdn.staticfile.org/smooth-scroll/16.1.0/smooth-scroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>

  
    <!-- Baidu Analytics -->
    <script>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?d54e5d165e17a670a03f855cd454a89a";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  




  <script src="https://cdn.staticfile.org/prettify/r298/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  ');
      prettyPrint();
    })
  </script>



  <script src="https://cdn.staticfile.org/typed.js/2.0.10/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "如果你交给某人一个程序,你将折磨他一整天；如果你教某人如何编写程序,你将折磨他一辈子。&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="https://cdn.staticfile.org/anchor-js/4.2.0/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>







</body>
</html>
