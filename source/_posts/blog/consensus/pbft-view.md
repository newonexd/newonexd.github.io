---
title: PBFT之视图更新
date: 2020-01-10 14:48:21
tags: 
- Pbft
- algorithm
categories:
- algorithm
---
# PBFT之视图更新
## 1 检查点
为了保证安全，除非消息中的请求至少已由*f+1*个无故障的副本节点执行，并且可以从视图更新中向其他节点证明，否则消息必须保留在副本节点日志中。另外，如果某些副本丢失了所有非故障副本节点丢弃的消息，则需要通过转移全部或部分服务状态来使消息更新。因此，副本也需要一些证明状态正确的证据。
在执行完所有操作之后生成这些证据的代价是昂贵的。相反，当执行的请求序列号可被某个常数(例如100)整除时，这些证据会定期生成。由执行完这些请求后根据状态机的状态产生的称为检查点，稳定的检查点就是该证据。
副本节点维护一些服务状态的逻辑拷贝:最新的稳定的检查点，零个或多个不稳定的检查点，还有当前状态。写时复制技术可以用于减少存储额外状态拷贝的空间负载。
作为证据的正确的检查点由以下步骤产生:
1. 当一个副本节点*i*生成了检查点，将会多播一个消息`<CHECKPOINT,n,d,i>_s`到其他副本节点。
    * *n*为状态中最新的被执行的请求序列号
    * *d*为状态的摘要
2. 每一个副本节点都会收集检查点信息，直到收集到*2f+1*个来自不同副本节点签名的具有相同序列号以及相同摘要*d*的消息
3. 将它们添加到日志中。这*2f+1*个消息即是证明该检查点正确的证明。
具有证明的检查点即是稳定的检查点，副本节点将会抛弃所有的序列号小于或等于日志中所有`pre-prepare,prepare,commit`消息中序列号的消息。同时也会抛弃之前所有的检查点以及检查点消息。
检查点协议用于推进低阈值标记和高阈值标记(限制可以接收多少消息)，低阈值*h*等于最新的稳定的检查点的序列号。高阈值*H=h+k*，其中*k*是足够大的数以至于副本节点不用一直等待检查点变为稳定的。例如，如果检查点包括接近100个请求，那么*k*可能为200.

## 2 视图更新过程
视图更新协议可以在系统中的*primary*虚假或崩溃时为系统提供活性。超时则会触发视图更新防止副本节点无限期地等待接收请求去执行。

* 如果副本接收到一个有效的请求并且还没有被执行，副本将会处于等待状态。
* 副本在接受到请求后并且计时器还没有处于运行时则会启动计时器。
* 当不再等待执行请求时，它将停止计时器，但如果此时正在等待执行其他请求，则将计时器重新启动。

1. 如果节点*i*在视图为*v*时计时器超时，该节点将会开始视图更新并且将视图变为*v+1*。停止接收信息(除了检查点，视图更新和新视图消息外)，并多播`<VIEW-CHANGE,v+1,n,C,P,i>_s`消息到所有副本节点。

    * *n*为节点*i*知道的最新的稳定检查点*s*的序列号。
    * *C*为一组*2f+1*个有效的检查点消息，它们证明检查点*s*的正确性
    * *P*是在节点*i*处的每个序列号高于*n*的请求消息*m*的`prepared`集合*Pm*的集合。
    * 每一个集合*Pm*包含*2f*个匹配的有效的`pre-prepare`消息(不包括与客户端相关的信息)，由不同的副本节点签名的具有相同视图，序列号，*m*的摘要的`prepare`消息。

2. 当*primary*在视图*v+1*时接收到*2f*个来自其他副本的视图为*v+1*的有效的`VIEW-CHANGE`消息后，将会多播一个`<NEW-VIEW,v+1,V,O>_s`消息到所有其他副本节点。

    * *V*为一个包含接收到的由*primary*发送的视图更改为*v+1*的有效的`VIEW-CHANGE`消息的集合。
    * *O*为一个*pre-prepare*消息的集合(不包含请求消息*m*),*O*通过以下内容计算:
        * *primary*决定关于*V*中最新的稳定的检查点的最小序列号*min-s*以及在*V*中的的*prepare*消息中最大的序列号*max-s*.
        * *primary*对每一个在*min-s*与*max-s*之间序列号*n*创建新的视图为*v+1*的*pre-prepare*消息。这里有两种情况:
            * 在*P*中至少有一个由一些在*V*中序列号为*n*的`VIEW-CHANGE`消息组成的集合。
            * 没有这样的集合

    在第一种情况下，*primary*创建新的消息`<PRE-PREPARE,v+1,n,d>_s`，这里的*d*为在*V*中序列号为*n*的高视图编号的`pre-prepare`消息的请求摘要。
    在第二种情况下，*primary*将会创建新的`<PRE-PREPARE,v+1,n,d_null>_s`消息，这里的*d_null*为指定的空的请求的摘要。空的请求在协议中和其他请求一样，只不过不进行执行。

3. 接下来*primary*添加*O*中的消息到日志中。如果*min-s*大于他的最新稳定的检查点的序列号，*primary*还在其日志中插入序列号为*min-s*的检查点的稳定性证明，并丢弃日志中的信息。这时候视图进入了*v+1*，在该点以后可以接收视图为*v+1*的消息。
4. 副本接收到关于视图为*v+1*的`NEW-VIEW`消息后，如果签名为正确的，且包含的内容对于视图是*v+1*是有效的，如果集合*O*是正确的(*O*的正确性通过与*primary*创建*O*时相同的计算过程进行验证).那么将该信息(正如*primary*描述的)添加到日志中。，多播在*O*中的`prepare`消息到其他所有副本中，并添加这些`prepare`消息到日志中，视图进入*v+1*。
5. 此后，正如三阶段提交协议过程，副本节点重新执行在*min-s*与*max-s*中的协议，但是避免重新执行客户端的请求(通过使用存储的关于最新的发送到每一个客户端的回复信息)。

副本可能会缺失某些请求消息*m*或者是稳定的检查点(由于没有发送`NEW-VIEW`消息)。这些缺失的信息可以从其他副本节点获取。
例如，副本*i*可以从一个副本节点(它的检查点信息已在*V*中确认正确性)获取缺失的检查点状态*s*.由于这些*f+1*个副本节点是正确的，副本节点*i*将总是获取*s*或者是最新的稳定检查点。通过对状态进行分区并为每个分区加上被修改的它的最后一个请求的序列号标记，可以避免发送整个检查点。要使副本为最新版本，只需将副本发送到过期的分区，而不是整个检查点。