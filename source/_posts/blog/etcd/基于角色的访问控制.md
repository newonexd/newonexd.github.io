---
title: 基于角色的访问控制
date: 2019-11-25 20:22:22
tags: etcd
categories: etcd文档翻译
---

原文地址：[Role-based access control](https://github.com/etcd-io/etcd/blob/master/Documentation/op-guide/authentication.md)
## 总览
* * *

身份验证已添加到etcd 2.1中。 etcd v3 API略微修改了身份验证功能的API和用户界面，以更好地适应新的数据模型。本指南旨在帮助用户在etcd v3中设置基本身份验证和基于角色的访问控制。

## 特殊用户和角色
* * *

有一个特殊用户`root`，一个特殊角色`root`。

### 用户`root`

在激活身份验证之前，必须创建对`etcd`具有完全访问权限的`root`用户。 `root`用户的想法是出于管理目的：管理角色和普通用户。 `root`用户必须具有`root`角色，并且可以在`etcd`中进行任何更改。

### 角色`root`

可以将角色`root`授予除`root`用户之外的任何用户。 具有`root`角色的用户既具有全局读写访问权限，又具有更新集群的身份验证配置的权限。 此外，`root`角色授予常规集群维护的特权，包括修改集群成员资格，对存储进行碎片整理以及拍摄快照。

## 用户的工作方式
* * *

`etcdctl`的`user`子命令处理与用户帐户有关的所有事情。
可以通过以下方式找到用户列表：
```
$ etcdctl user list
```
通过以下方式创建新用户：
```
$ etcdctl user add myusername
```
创建新用户将提示您输入新密码。 当给出选项`--interactive=false`时，可以从标准输入中提供密码。 `--new-user-password`也可以用于提供密码。

可以通过以下方式为用户授予和撤消角色：

```
$ etcdctl user grant-role myusername foo
$ etcdctl user revoke-role myusername bar
```

可以使用以下命令检查用户的设置：
```
$ etcdctl user get myusername
```

用户密码可以通过以下方式更改：

```
$ etcdctl user passwd myusername
```

更改密码将再次提示您输入新密码。 当给出选项`--interactive=false`时，可以从标准输入中提供密码。

通过以下方式删除帐户：
```
$ etcdctl user delete myusername
```

### 角色的工作方式：
* * *

`etcdctl`的`role`子命令处理与授予特定用户的特定角色的访问控制有关的所有事情。

列出角色：
```
$ etcdctl role list
```

创建一个新角色：
```
$ etcdctl role add myrolename
```

角色没有密码； 它仅定义了一组新的访问权限。

授予角色访问单个密钥或一系列密钥的权限。

范围可以指定为间隔[开始键，结束键]，其中开始键应按字母顺序在词汇上小于结束键。

可以将访问权限授予读取，写入或同时授予两者，如以下示例所示：
```
# Give read access to a key /foo
$ etcdctl role grant-permission myrolename read /foo

# Give read access to keys with a prefix /foo/. The prefix is equal to the range [/foo/, /foo0)
$ etcdctl role grant-permission myrolename --prefix=true read /foo/

# Give write-only access to the key at /foo/bar
$ etcdctl role grant-permission myrolename write /foo/bar

# Give full access to keys in a range of [key1, key5)
$ etcdctl role grant-permission myrolename readwrite key1 key5

# Give full access to keys with a prefix /pub/
$ etcdctl role grant-permission myrolename --prefix=true readwrite /pub/
```

要查看授予的权限，我们可以随时查看该角色：
```
$ etcdctl role get myrolename
```

撤消权限是按照相同的逻辑方式完成的：
```
$ etcdctl role revoke-permission myrolename /foo/bar
```

就像完全删除一个角色一样：
```
$ etcdctl role delete myrolename
```

### 开启身份认证
* * *

启用身份验证的最少步骤如下。 管理员可以根据喜好在启用身份验证之前或之后设置用户和角色。

确保已创建root用户：
```
$ etcdctl user add root
Password of root:
```

开启身份认证
```
$ etcdctl auth enable
```

此后，etcd在启用身份验证的情况下运行。 要出于任何原因禁用它，请使用reciprocal命令：
```
$ etcdctl --user root:rootpw auth disable
```

### 使用`etcdctl`进行身份验证
* * *

`etcdctl`支持类似`curl`的标志进行身份验证。
```
$ etcdctl --user user:password get foo
```

可以从提示符处获取密码：
```
$ etcdctl --user user get foo
```

密码也可以从命令行参数`--password`获取：
```
$ etcdctl --user user --password password get foo
```

否则，所有`etcdctl`命令均保持不变。 用户和角色仍然可以创建和修改，但是需要具有`root`角色的用户进行身份验证。

### 使用TLS通用名称
* * *

从v3.2版本开始，如果使用参数`--client-cert-auth=true`启动etcd服务器，则客户端的TLS证书中的“通用名称（CN）”字段将用作etcd用户。在这种情况下，公用名将对用户进行身份验证，并且客户端不需要密码。请注意，如果同时传递了1. `--client-cert-auth=true`且客户端提供了CN，并且客户端提供了2.用户名和密码，则将优先考虑基于用户名和密码的身份验证。请注意，此功能不能与`gRPC-proxy`和`gRPC-gateway`一起使用。这是因为`gRPC-proxy`会从其客户端终止TLS，因此所有客户端都共享代理证书。 `gRPC-gateway`内部使用TLS连接将HTTP请求转换为gRPC请求，因此它具有相同的限制。因此，客户端不能正确地将其CN提供给服务器。如果给定证书的CN不为空，则`gRPC-proxy`将导致错误并停止。 `gRPC-proxy`返回错误，表明客户端证书中的CN为非空。


从v3.3版本开始，如果启用了带有选项`--peer-cert-allowed-cn`或`--peer-cert-allowed-hostname`的`etcd`服务器启动，则对等节点连接筛选。如果节点的TLS证书身份与允许的节点匹配，则节点只能加入etcd集群。有关更多详细信息，请参见[etcd安全性页面](https://newonexd.github.io/2019/11/25/blog/etcd/TLS/)。